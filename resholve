#!/usr/bin/env python2
from __future__ import print_function

__version__ = "@version@"
__version_info__ = (x for x in __version__.split("."))
DIRECTIVE_FORMAT = "2"

import sys
import os
import StringIO

# TODO: one of the two below :)
import configargparse as argparse
import logging

from collections import defaultdict
from distutils.spawn import find_executable

logger = logging.getLogger(__name__)
logging.basicConfig(level=os.environ.get("LOGLEVEL", logging.WARNING))
# logging.basicConfig(filename='example.log', filemode='w', level=logging.DEBUG)

import oil
import importlib

"""
This is all a little arcane, so it's worth explaining a bit.

Oil isn't really packaged as a library. Initially I forked
and packaged for expediency, and because I was hoping to be
able to upstream the package definition. Oil has resisted
this, but I also want to minimize the work it takes to get
caught up with upstream at any given time.

Unfortuately, forcing a namespace on Oil and using it in
resholve isn't enough on its own.

A byproduct of the fact that it isn't already packaged and
that it runs on python2, is that oil's internal imports
aren't namespaced, and are a bit of a nest. Some of the
package names are generic (i.e., "misc", and "tools"), so
I want to force a namespace on oil, but without having to
fork and maintain a large change.

Thus, we're here monkeypatching __builtins__.__import__ in
order to (try) to:
- detect when something in oil is importing
- try first to prefix it with "oil." and fall back if not
  (this should import oil stuff from oil., but not block
  batteries and other packages)

TODO: This isn't terribly rigorous. A marginal improvement
would be generating a list of packages (or maybe the whole
tree) at build time, and only fiddling with these.

CAUTION: There's a demon in here. It's possible for different
paths to lead to distinct imports, and for isinstance() to
fail on some things it should succeed on.
"""
import_cache = dict()
# TODO: I don't like hard-coding these
_oil_extensions = {
    "fastlex",
    "libc",
    "lineinput",
    "posix_",
}


def _import(name, *args):
    _globals, _locals, _ids = args[0:3]
    _lvl = args[3] if len(args) > 3 else -1

    current_file = _globals["__file__"]
    ret = None
    if "/oil/" in current_file and name not in _oil_extensions:
        # logger.debug("rewrite oil's imports to %r", name)
        oilyname = "oil." + name
        if name in import_cache and oilyname in import_cache:
            # logger.debug("both name and oilyname are in import_cache; returning early")
            if id(import_cache[oilyname]) != id(import_cache[name]):
                raise Exception("Module IDs differ")
            return import_cache[name]
        try:
            ret = original_import(oilyname, _globals, _locals, _ids, _lvl)
            # logger.debug(
            #     "putting %r in import cache with name %r and id %r",
            #     ret,
            #     oilyname,
            #     id(ret),
            # )
            import_cache[oilyname] = ret

            # but also add it under the un-rewritten name
            sys.modules[name] = ret

            if (
                len(
                    set(
                        [
                            id(ret),
                        ]
                    )
                )
                > 1
            ):
                raise Exception("Module IDs unexpectedly differ")
        except ImportError:
            ret = original_import(name, _globals, _locals, _ids, _lvl)
            # logger.debug(
            #     "putting %r in import cache with name %r and id %r", ret, name, id(ret),
            # )
            import_cache[name] = ret

    if not ret:
        ret = original_import(name, _globals, _locals, _ids, _lvl)
        # logger.debug(
        #     "putting %r in import cache with name %r and id %r", ret, name, id(ret)
        # )
        import_cache[name] = ret

    # logger.debug(
    #     "%r is trying to import %r and we're returning %r ", current_file, name, ret
    # )

    return ret


original_import = __builtins__.__import__
__builtins__.__import__ = _import

# NOTE:
#   All of the below are imports from/for oil. Try to keep careful notes here on
#   what is being used from each Oil module. Oil is still changing very
#   quickly, and it's easier to track upstream changes with a succinct set of
#   notes.

# NOTE: not from oil, but just to support a rewritten variant
# of oil code (find_dynamic_token)
from typing import cast  # only in find_dynamic_token
from oil.mycpp.mylib import tagswitch  # only in find_dynamic_token

from oil.asdl import pybase  # CompoundObj

from oil.core import alloc  # Arena
from oil.core import error  # Parse, _ErrorWithLocation
from oil.core import main_loop  # ParseWholeFile
from oil.core import optview  # Parse
from oil.core import ui  # PrettyPrintError

from oil.osh import word_  # LeftMostSpanForWord, RightMostSpanForWord StaticEval

# LookupSpecialBuiltin, LookupAssignBuiltin, LookupNormalBuiltin, NO_INDEX
from oil.frontend import consts
from oil.frontend import parse_lib  # ParseContext
from oil.frontend import (
    reader,
)  # FileLineReader (only into ParseContext().MakeOshParser)

from oil._devbuild.gen.id_kind_asdl import Id  # VSub_Number, VSub_Name, VSub_DollarName

from oil._devbuild.gen.syntax_asdl import (
    source,  # MainFile, Stdin
    word_part_e,  # ArithSub, AssocArrayLiteral, BracedVarSub, CommandSub, DoubleQuoted, EscapedLiteral, ExtGlob, Literal, ShArrayLiteral, SimpleVarSub, SingleQuoted, Splice, TildeSub
    command,  # ShFunction, Simple
    double_quoted,  # directly for cast()
    Token,  # directly for cast(), also for alias parsing
)

from oil.tools import osh2oil  # Cursor


executables = dict()
resolved_scripts = dict()


def span_pair(word_object, arena):
    return (
        arena.GetLineSpan(word_.LeftMostSpanForWord(word_object)),
        arena.GetLineSpan(word_.RightMostSpanForWord(word_object)),
    )


class ResolutionDirectives(object):
    fake = fix = keep = None

    def __init__(self, fake=None, fix=None, keep=None):
        self.fake = fake or set()
        self.fix = fix or set()
        self.keep = keep or set()

    def __len__(self):
        return len(self.fake) + len(self.fix) + len(self.keep)

    def update(self, *peers):
        for peer in peers:
            assert isinstance(peer, ResolutionDirectives)
            self.fake.update(peer.fake)
            self.fix.update(peer.fix)
            self.keep.update(peer.keep)

    @staticmethod
    def _type_tuple(type, entry):
        if len(entry) == 1:
            return (type, entry[0])
        if len(entry) == 2:
            return (type, entry[0], entry[1])

    def difference(self, *peers):
        out = set()
        for peer in peers:
            assert isinstance(peer, ResolutionDirectives)
            for fake in self.fake.difference(peer.fake):
                out.add((self._type_tuple("fake", fake)))
            for fix in self.fix.difference(peer.fix):
                out.add((self._type_tuple("fix", fix)))
            for keep in self.keep.difference(peer.keep):
                out.add((self._type_tuple("keep", keep)))

        return out

    def relevant(self, name):
        def rel_filt(val):
            if len(val) == 1:
                return name == val[0]
            if len(val) == 2:
                return name == val[1]

        return self.__class__(
            fake=filter(rel_filt, self.fake),
            fix=filter(rel_filt, self.fix),
            keep=filter(rel_filt, self.keep),
        )


directives = ResolutionDirectives()


def parse_directive(value, scope_map=None):
    if not len(value):
        return None
    out = set()
    try:
        directives = value.split(" ")
        logger.debug("directives: %r", directives)
        for directive in directives:
            rules = directive.split(":", 1)
            if len(rules) == 1:
                out.add((rules[0],))
                continue
            elif len(rules) == 2:
                scope = rules[0] if not scope_map else scope_map(rules[0])
                rules = rules[1]
                rules = rules.split(";")
                for rule in rules:
                    out.add((scope, rule))
            else:
                raise argparse.ArgumentTypeError(
                    "Directives may not have more than one colon: %r" % directive
                )
    except ValueError as e:
        raise argparse.ArgumentTypeError(
            "I don't recognize %r as a known directive. See 'man resholve'." % value
        )
    return out


FAKE_DIRECTIVE_MAP = {
    "a": "alias",
    "b": "builtin",
    "e": "external",
    "f": "function",
    "k": "keyword",
    "s": "source",
}
FAKE_DIRECTIVE_TYPES = set(FAKE_DIRECTIVE_MAP.keys()) | set(FAKE_DIRECTIVE_MAP.values())


def remap_fake_scope(scope):
    global FAKE_DIRECTIVE_MAP
    if scope in FAKE_DIRECTIVE_MAP:
        return FAKE_DIRECTIVE_MAP[scope]
    else:
        return scope


# TODO: arg tests for all of these formats
def directive_fake(value):
    global FAKE_DIRECTIVE_TYPES
    directives = parse_directive(value, remap_fake_scope)
    if not directives:
        return None
    for directive in directives:
        if len(directive) == 1:
            raise argparse.ArgumentTypeError(
                "valid fake directives must have at least two parts"
            )
        elif directive[0] not in FAKE_DIRECTIVE_TYPES:
            raise argparse.ArgumentTypeError(
                "fake directive type (%r) is not one of %r"
                % (directive[0], FAKE_DIRECTIVE_TYPES)
            )

    return directives


def directive_fix(value):
    directives = parse_directive(value)
    if not directives:
        return None
    logger.debug("validating fix directives %r", directives)
    for directive in directives:
        if len(directive) == 1:
            logger.debug("%r %r", directive[0], directive[0] == "aliases")
            if directive[0] == "aliases":
                pass  # ok literal
            elif os.path.isabs(directive[0]):
                pass  # ok absolute path
            else:
                raise argparse.ArgumentTypeError(
                    "valid single-part fix directives: 'aliases', absolute path"
                )
        elif len(directive) == 2:
            # we can't validate $variable or outer_command before parse
            # but we can pre-validate command lookup for the target
            target = lookup(directive[1])
            if not target:
                raise argparse.ArgumentTypeError(
                    "I couldn't resolve '{command}' in directive {scope}:{command}".format(
                        scope=directive[0], command=directive[1]
                    )
                )
    return directives


def directive_keep(value):
    directives = parse_directive(value)
    if not directives:
        return None
    logger.debug("validating keep directives %r", directives)
    for directive in directives:
        if len(directive) == 1:
            if directive[0][0] == "$":
                pass  # ok literal
            elif directive[0][0:2] == "~/" and os.path.isabs(
                os.path.expanduser(directive[0])
            ):
                pass
            elif os.path.isabs(directive[0]):
                pass  # ok absolute path
            else:
                raise argparse.ArgumentTypeError(
                    "valid single-part keep directives: $variable, absolute path, ~/path"
                )
        elif len(directive) == 2:
            pass
            # can't do much to pre-validate these
    return directives


def make_arg_parser(module):
    parser = module.ArgumentParser(
        description="Resolve external command/script references in a shell script to absolute paths. This is a terse reminder of flag names; see 'man resholve' for usage.",
        usage="resholve [options] script ...",
        auto_env_var_prefix="RESHOLVE_",
        add_env_var_help=False,
        add_help=False,
    )

    req = parser.add_argument_group(
        title="Required",
    )
    req_path = req.add_mutually_exclusive_group(required=True)

    req.add_argument(
        "scripts",
        metavar="script",
        type=str,
        nargs="*",
        help="script paths to resolve",
    )
    req_path.add_argument(
        "--path",
        metavar="str",
        dest="path",
        type=str,
        help="paths to resolve commands from",
    )
    req_path.add_argument(
        "--inputs",
        metavar="str",
        dest="path",
        type=str,
        help="alias for --path",
    )

    req.add_argument(
        "--interpreter",
        dest="interpreter",
        type=str,
        metavar="p",
        help="specify interpreter for shebang; does NOT otherwise impact how resholve interprets a script",
        required=True,
    )

    res = parser.add_argument_group(
        title="Controlling resolution",
    )

    res.add_argument(
        "--fake",
        metavar="str",
        action="append",
        type=directive_fake,
        help="pretend some commands exist",
    )
    res.add_argument(
        "--fix",
        metavar="str",
        action="append",
        type=directive_fix,
        help="fix things we can't auto-fix/ignore",
    )
    res.add_argument(
        "--keep",
        metavar="str",
        action="append",
        type=directive_keep,
        help="keep things we can't auto-fix/ignore",
    )

    other = parser.add_argument_group(title="Other")

    other.add_argument(
        "--prologue",
        type=argparse.FileType("r"),
        metavar="f",
        help="insert file before resolved script",
    )
    other.add_argument(
        "--epilogue",
        type=argparse.FileType("r"),
        metavar="f",
        help="insert file after resolved script",
    )

    other.add_argument(
        "--overwrite",
        action="store_true",
        dest="overwrite",
        help="Replace script files instead of writing to script.resolved.",
    )
    # other.add_argument(
    #     "--faff", type=int, metavar="int", help="fuzz n times for missed commands",
    # )
    meta = parser.add_argument_group(title="Meta")
    meta.add_argument(
        "-h", "--help", action="help", help="show this help message and exit"
    )
    meta.add_argument(
        "--version",
        action="version",
        version="%(prog)s {:}".format(__version__),
    )

    return parser


parser = make_arg_parser(argparse)


def lookup(word):
    if word not in executables:
        executables[word] = find_executable(word)
    return executables[word]


# TODO: refactor to deduplicate this before/after stuff
def resolve_script(script_path, shebang="", prologue=None, epilogue=None):
    if script_path in resolved_scripts:
        return resolved_scripts[script_path]

    resolved = resolved_scripts[script_path] = ResolvedScript(
        script_path, shebang=shebang, prologue=prologue, epilogue=epilogue
    )
    return resolved


def write_resolved_script(script_path, resolved, overwrite=False):
    if not script_path:
        resolved.write_to()
    elif overwrite:
        logger.info("attempting to overwrite script %r", script_path)
        resolved.write_to(script_path)
        sys.stderr.write("Overwrote %r\n" % (script_path))
    else:
        logger.info(
            "overwrite not set; will attempt to write to: %s%s",
            script_path,
            ".resolved",
        )
        resolved.write_to(script_path + ".resolved")
        sys.stderr.write(
            "Rewrote %r to %r\n" % (script_path, script_path + ".resolved")
        )


def lookup_source(word):
    """
    wrap lookup(word) to special-case source lookups

    lookup can't resolve something like `source submodule/helper.sh`
    unless we add subdirs to PATH, but that could let all kinds of
    stuff into the resolution scope.

    Instead, we'll try to resolve source calls from the list of
    input scripts before giving lookup a chance.

    This is a little weird, but this is a not-implemented stub for
    documentation. The business-end of this function is temporarily
    published the sourcePATH() context manager during punshow()
    """
    raise NotImplementedError("lookup_source called outside of sourcePATH context")


from contextlib import contextmanager


@contextmanager
def sourcePATH(script_map):
    global lookup_source

    def contextual_lookup_source(word):
        if word in script_map:
            return script_map[word]
        return lookup(word)

    prev = lookup_source
    lookup_source = contextual_lookup_source
    yield
    lookup_source = prev


def punshow():
    args = parser.parse_args()
    # if it makes sense at some point, vars(args) yields a dict of these
    # that can be passed as kwargs or something...
    logger.info("argparsed: %r", args)
    logger.debug("argument sources: \n%s", parser.format_values())

    # adopt the runtime dependency path for resolving external executables
    if args.path is None:
        # made this not-required in order to support both "path" and
        # "inputs" terminology (inputs is more nix-idiomatic) but
        # store in a single dest; fake our own error
        parser.error(
            "argument --path/--inputs (or RESHOLVE_PATH/RESHOLVE_INPUTS) is required"
        )
    os.environ["PATH"] = args.path

    if args.fake:
        for group in args.fake:
            directives.fake.update(group)

    if args.fix:
        for group in args.fix:
            directives.fix.update(group)

    if args.keep:
        for group in args.keep:
            directives.keep.update(group)

    if ("aliases",) not in directives.fix:
        RecordCommandlike.disable_alias_replacement()

    if args.interpreter == "none":
        shebang = None
    else:
        interp = args.interpreter
        assert os.path.exists(interp), "Interpreter must exist or be the string 'none'"
        assert os.path.isabs(interp), "Interpreter path must be absolute"
        assert os.access(interp, os.X_OK), "Interpreter must be executable"
        shebang = "#!{:}\n".format(interp)
    try:
        to_write = set()
        if len(args.scripts) == 0:
            # None == <stdin>
            with sourcePATH(dict()):
                resolved_scripts[None] = ResolvedScript(
                    shebang=shebang, prologue=args.prologue, epilogue=args.epilogue
                )
                to_write.add(None)

        checked_scripts = list()
        script_map = dict()
        for in_script in args.scripts:
            abs_script = os.path.abspath(in_script)
            if os.path.exists(abs_script):
                checked_scripts.append(abs_script)
                script_map[in_script] = abs_script
            else:
                sys.stderr.write("Aborting due to missing file: %r\n" % abs_script)
                return 2

        if len(set(checked_scripts)) != len(checked_scripts):
            sys.stderr.write(
                "Aborting due to duplicate script targets.\n"
                "Verify your inputs and try again.\n"
            )
            sys.stderr.write("  Original: %r\n" % args.scripts)
            sys.stderr.write("  Distinct: %r\n" % set(checked_scripts))
            return 2

        with sourcePATH(script_map):
            for script in checked_scripts:
                resolve_script(
                    script,
                    shebang=shebang,
                    prologue=args.prologue,
                    epilogue=args.epilogue,
                )
                to_write.add(script)

        # cmdlikes are cross-source; try to resolve a single time
        resolve_cmdlikes()

        for script_path in to_write:
            write_resolved_script(
                script_path, resolved_scripts[script_path], args.overwrite
            )

    except IOError as e:
        sys.stderr.write("Whoooo buddy: " + str(e))
        return 2
    except ResolutionError as e:
        e.print_if_needed()
        return e.exit_status
    except error._ErrorWithLocation as e:
        if hasattr(e, "print_if_needed"):
            e.print_if_needed()
        elif hasattr(e, "arena"):
            ui.PrettyPrintError(e, e.arena, getattr(e, "label", "error: "))
        else:
            print(
                "This error has location context I couldn't "
                "figure out how to print. Please report this "
                "@ https://github.com/abathur/resholve/issues",
                repr(e),
            )
        if hasattr(e, "exit_status") and e.exit_status is not None:
            return e.exit_status
        else:
            return 2
    except InFileDirectiveError as e:
        sys.stderr.write(str(e))
        return 2
    except argparse.ArgumentTypeError as e:
        sys.stderr.write("Hold up there, cowpoke: " + str(e))
        return 2
    # except Exception as e:
    #     raise e
    # I was doing the below, but I'm not sure why I wouldn't want to surface a real error here for now; it seems like this will only make debugging harder
    # print(type(e))
    # sys.stderr.write("whoooo buddy " + str(e))
    # return 2
    # print(len(resolved_scripts))
    # for script, resolver in resolved_scripts.items():
    #     print(script)
    #     print(resolver.funcs_defined)


def find_dynamic_token(part):
    # type: (word_part_t) -> token|bool
    """Recursive search for dynamic token.

    This is patterned on oil's word_._EvalWordPart, but with
    roughly inverted boolean logic: it returns the token object
    if one is found, otherwise False.
    """
    UP_part = part
    with tagswitch(part) as case:
        if case(word_part_e.ShArrayLiteral):
            return cast(Token, UP_part).token

        elif case(word_part_e.AssocArrayLiteral):
            return cast(Token, UP_part).token

        elif case(word_part_e.Literal):
            return False

        elif case(word_part_e.EscapedLiteral):
            return False

        elif case(word_part_e.SingleQuoted):
            return False

        elif case(word_part_e.DoubleQuoted):
            part = cast(double_quoted, UP_part)
            for p in part.parts:
                tok = find_dynamic_token(p)
                if tok:
                    return tok

            return False

        elif case(
            word_part_e.CommandSub,
            word_part_e.SimpleVarSub,
            word_part_e.BracedVarSub,
            word_part_e.TildeSub,
            word_part_e.ArithSub,
            word_part_e.ExtGlob,
            word_part_e.Splice,
        ):
            return cast(Token, UP_part).token
        else:
            raise AssertionError(part.tag_())


# before, we had to do optview.parse([False] * option_i.ARRAY_SIZE) and
# optview.Exec([False] * option_i.ARRAY_SIZE, errexit)
class FalseListFake(object):
    def __getitem__(self, option):
        return False


NO_OPTIONS = FalseListFake()


class ExceptionWithContext(error._ErrorWithLocation):
    pass


class ResolutionError(ExceptionWithContext):
    printed = False
    arena = None

    def __init__(self, *args, **kwargs):
        self.arena = kwargs.pop("arena", None)
        ExceptionWithContext.__init__(self, *args, **kwargs)

    def print_if_needed(self):
        if not self.printed:
            ui.PrettyPrintError(self, self.arena)
            self.printed = True


class ResolutionWarning(ExceptionWithContext):
    printed = False
    arena = None
    label = "WARNING: "

    def __init__(self, msg, *args, **kwargs):
        self.arena = kwargs.pop("arena")
        error._ErrorWithLocation.__init__(self, self.label + msg, *args, **kwargs)
        self.print_if_needed()

    def print_if_needed(self):
        if not self.printed:
            ui.PrettyPrintError(self, self.arena)
            self.printed = True


EMIT_FEEDBACK_REQUESTS = False
if logger.isEnabledFor(logging.WARNING):
    EMIT_FEEDBACK_REQUESTS = True

    class FeedbackWantedWarning(ResolutionWarning):
        label = "FEEDBACK WANTED: "


class InFileDirectiveError(Exception):
    directive = path = None
    template = (
        "There's a bad directive already in this file. You may need to\n"
        "re-resholve it with the current version? Here's the context:\n\n"
        "   parsing:  {script}\n"
        " directive:  '{directive}'\n"
        "     error:  {msg}\n"
    )

    def __init__(self, msg, path, directive, *args, **kwargs):
        Exception.__init__(
            self,
            self.template.format(
                msg=msg,
                script=os.path.relpath(path),
                directive=directive[0:-1],  # lop off newline
            ),
            *args,
            **kwargs
        )


class SingleKeyDefaultDict(dict):
    def __init__(self, factory):
        self.factory = factory

    def __missing__(self, key):
        return self.setdefault(key, self.factory(key))


class MultiKeyDefaultDict(dict):
    def __init__(self, factory):
        self.factory = factory

    def __missing__(self, key):
        return self.setdefault(key, self.factory(*key))


"""
It's probably worth discussing the big picture before the next section. It may
be a little arcane, but it's in the service of minimizing repeated work.

When resholve process a script, it runs it through Oil's OSH parser and then
visits the corresponding AST looking for "command-like" words (those used as
if they are a command) to queue them for resolution. On encounter, we can't,
rule out the possibility that it's an alias defined 3 scripts down a source
chain without parsing everything before we start resolving--so we queue.

On each encounter, the visitor calls a context-specific record_ method from
the RecordCommandlike mixin to. Each of these methods corresponds to a known
command resolution order--a sequence of the types of command this command-like
would resolve to. (Resolution rules differ across different contexts, like
inside an alias, and following certain commands). This call:

- Maps the position of the command-like to the AST word object (for reporting)
  self.word_objects[position] = word_object

- Checks defaultdict cmdlikes[word_string] for the CommandLike instance that
  corresponds to this word. This instance will accumulate information like
  which scripts it appears in, whether it's defined as a function or alias,
  and most importantly the distinct resolution orders where it was found.

- Maps the command-like's position to a Solution instance (obtained from the
  CommandLike) that is distinct for each encountered resolution order:
  self.solutions[position] = Solution

  If the visitor encounters the same commandlike 5 separate times but with the
  same resolution order, the solutions dictionary will map *all 5* positions
  to the same object.

Once the visitor has finished, we call CommandLike.resolve() on all known
CommandLike objects. Each CommandLike will "solve" for the distinct contexts
it was found in, and add the appropriate resolution to the corresponding
Solution object. This process records whether each Solution should be a no-op,
raise an exception, or result in a replacement.

Next, we render the resolved script by looping over each of these solutions.
"""


class Solution(object):
    """
    Mutable placeholder objects to pair with commandlike encounters.

    We can't solve the commandlike until we're done parsing, but we
    know enough context at encounter time to deduplicate solutions.
    Calling code will save a reference to the context-appropriate
    solution object for each encounter, and a single solution pass
    later can identify the correct replacement for each one.
    """

    replacement = None
    exception = None

    @property
    def solved(self):
        return self.replacement is not None or self.exception is not None

    def no_change(self):
        self.replacement = False

    def replace_name_with(self, name, replacement, external=False):
        self.replacement = (name, replacement)

    def replace_in(self, current):
        return current.replace(*self.replacement)

    def causes_exception(self, exception):
        self.exception = exception


class OrderedCommandResolver(object):
    KNOWN_BUILTINS = {
        ".",
        ":",
        "[",
        "alias",
        "bg",
        "bind",
        "break",
        "builtin",
        "caller",
        "cd",
        "command",
        "compgen",
        "complete",
        "compopt",
        "continue",
        "declare",
        "dirs",
        "disown",
        "echo",
        "enable",
        "eval",
        "exec",
        "exit",
        "export",
        "false",
        "fc",
        "fg",
        "getopts",
        "hash",
        "help",
        "history",
        "jobs",
        "kill",
        "let",
        "local",
        "logout",
        "mapfile",
        "popd",
        "printf",
        "pushd",
        "pwd",
        "read",
        "readarray",
        "readonly",
        "return",
        "set",
        "shift",
        "shopt",
        "source",
        "suspend",
        "test",
        "times",
        "trap",
        "true",
        "type",
        "typeset",
        "ulimit",
        "umask",
        "unalias",
        "unset",
        "wait",
    }
    KNOWN_UNHANDLED_KEYWORDS = {"coproc"}

    @property
    def name(self):
        return self.cmd.name

    def _true(self):
        return True

    def _false(self):
        return False

    def _unexpected_absolute_path(self):
        raise ResolutionError(
            "Unexpected absolute command path (not supplied by a listed dependency). You should patch/substitute it.",
            # the others are errors too, but we'll just flag the first
            status=5,
        )

    def generate_external_resolver(self, relevant):
        if self.name.startswith("/") and os.path.isabs(self.name):
            if (self.name,) in relevant.keep:
                # user said keep this abspath
                return self._true
            elif (self.name,) in relevant.fix:
                # user said to resolve this abspath as if it were bare
                self.cmd.name = os.path.basename(self.name)
                return self.resolve_external
            else:
                return self._unexpected_absolute_path
        # if self.name isn't absolute, see if ('external', self.name) is in fake directives?
        elif ("external", self.name) in relevant.fake:
            return self._true

        return self.resolve_external

    def __init__(self, commandlike, relevant):
        self.cmd = commandlike
        # "cro" is "command resolution order"; open to renames
        # alias > keyword > special builtin > function > builtin > external
        #                  (POSIX mode only)
        # neither special builtins nor POSIX mode have special handling atm
        # just saving space for them in case...
        self.cro = (
            self._true if ("alias", self.name) in relevant.fake else self.resolve_alias,
            self._true
            if ("keyword", self.name) in relevant.fake
            else self.resolve_keyword,
            self.resolve_special_builtin,
            self._true
            if ("function", self.name) in relevant.fake
            else self.resolve_function,
            self._true
            if ("builtin", self.name) in relevant.fake
            else self.resolve_builtin,
            self._true
            if ("external", self.name) in relevant.fake
            else self.generate_external_resolver(relevant),
        )

    @property
    def full(self):
        # alias > keyword > special builtin > function > builtin > external
        return self.cro

    @property
    def alias(self):
        return self.cro[3:]  # function > builtin > external

    @property
    def builtin(self):
        return self.cro[4:5]  # builtin

    @property
    def command(self):
        return self.cro[4:]  # builtin > external

    @property
    def external(self):
        return self.cro[5:]  # external

    """
    CommandLike.resolve() will call below methods for each distinct
    CRO encountered, and stop on the first that returns truthy.

    So they have the same basic rules:
    - return True if this is a valid resolution without change
    - return False if not (or None if unimplemented/irrelevant)
    - return a string to indicate a valid resolution with replacement
    - raise an exception to indicate a problem *(see resolve_external
      for a quirk about raising exceptions here)

    TODO: in theory these can be cached, but I'm not sure it'll be
    meaningful. The expensive part, lookup(), is already cached.
    """

    def resolve_alias(self):
        return self.cmd.alias

    def resolve_keyword(self):
        """
        I wanted to leave this unimplemented and let oil's parser
        shield resholve from needing to worry about it

        but oil doesn't handle the coproc keyword, so that's forcing
        my hand here.
        """
        return True if self.name in self.KNOWN_UNHANDLED_KEYWORDS else False

    def resolve_special_builtin(self):
        """
        leaving special builtin unimplemented for now; it's a
        posix-mode concept I'm hoping to avoid supporting.
        only time it really matters is if a function obscures
        a "special" builtin in posix mode

        See the file 'POSIX_mode_notes'
        """
        pass

    def resolve_function(self):
        return self.cmd.function

    def resolve_builtin(self):
        """
        TODO: code this is based on once looked up builtins oil's way
        but the list of builtins there are probably oil's:
        if (
            consts.LookupSpecialBuiltin(text) == consts.NO_INDEX
            and consts.LookupAssignBuiltin(text) == consts.NO_INDEX
            and consts.LookupNormalBuiltin(text) == consts.NO_INDEX
        ):

        I'm not sure to what extent I want to support non-bash shells,
        but if there's a push to do so it may help to post this on SO
        or make little help-wanted issues.

        The ~most-right way to do this would be to get the builtins
        from the target shell (at build-time? call-time?) but I'm not
        aware of a portable way to do it.

        If one's identified, the Nix side could accept a shell (or
        shells?) argument, run that command in each, merge the lists,
        and supply them via env.

        For now, I'm just hard-coding a list of bash builtins from
        `compgen -b` run in GNU bash,
        version 5.0.9(1)-release (x86_64-apple-darwin17.7.0)

        NOTE: if you're using resholve for some other shell and have
        a builtin not in this list, you can add an exemption with
        --allow builtin:<name>
        """
        return True if self.name in self.KNOWN_BUILTINS else False

    def resolve_external(self):
        executable = lookup(self.name)
        if not executable:
            # Types of ExceptionWithContext need other values in order
            # to pretty-print the error location that just aren't
            # readily available at this place using the current logic.
            #
            # Instead, we just mark the status, and code higher up the
            # stack will catch this error, inject the correct arena and
            # location information for us, and then re-raise the error.
            raise ResolutionError(
                "Can't resolve command %r to a known function or executable",
                self.name,
                status=3,
            )
        else:
            return executable


class CommandLike(object):
    """
    Represents each distinct command-like "word" we encounter.
    """

    name = function = alias = None

    def __init__(self, name):
        self.name = name
        self.known_sources = dict()
        self.known_exemptions = list()
        self.order_to_source = defaultdict(set)
        self.order_to_solution = defaultdict(Solution)
        self.cros = MultiKeyDefaultDict(OrderedCommandResolver)

    def scaffold_new_source(self, source):
        # only exemptions that match this commandlike's name
        # tuple only really for hashability...
        relevant = source.directives.relevant(self.name)

        if relevant in self.known_exemptions:
            # new source, but no novel exemptions
            index = self.known_exemptions.index(relevant)

            # use existing content-identical set to
            # approximate a "set of sets"
            self.known_sources[source] = self.known_exemptions[index]
        else:
            # new source with novel exemptions
            self.known_sources[source] = relevant
            self.known_exemptions.append(relevant)

        return self.cros[(self, relevant)]

    def request_solution(self, source, order):
        self.order_to_source[order].add(source)
        return self.order_to_solution[order]

    def find_cro(self, source):
        if source not in self.known_sources:
            return self.scaffold_new_source(source)
        return self.cros[(self, self.known_sources[source])]

    def request_full_solution(self, source):
        return self.request_solution(source, self.find_cro(source).full)

    def request_alias_solution(self, source):
        return self.request_solution(source, self.find_cro(source).alias)

    def request_builtin_solution(self, source):
        return self.request_solution(source, self.find_cro(source).builtin)

    def request_command_solution(self, source):
        return self.request_solution(source, self.find_cro(source).command)

    def request_external_solution(self, source):
        return self.request_solution(source, self.find_cro(source).external)

    def resolve(self):
        # find solutions for observed types
        for distinct_cro, solution in self.order_to_solution.items():

            # run each function, break early on exception/true/string
            for func in distinct_cro:
                try:
                    # TODO: could cache these, but not sure it'll make much diff
                    test = func()
                except ExceptionWithContext as e:
                    solution.causes_exception(e)
                    break

                if test == True:
                    solution.no_change()
                    break
                elif test:
                    # only external can return more than just t/f
                    solution.replace_name_with(self.name, test)
                    for source in self.order_to_source[distinct_cro]:
                        source.directives.keep.add((test,))
                    break

            # TODO: rm if not seen for a while? Not sure how long... --Jun 27, 2020
            if not solution.solved:
                raise Exception(
                    "Can't resolve command %r to a known function or executable? I think this is obsolete now that resolve_external raises a similar error, but I won't hastily remove it..."
                    % self.name
                )


cmdlikes = SingleKeyDefaultDict(CommandLike)


def resolve_cmdlikes():
    logger.info("Resolving command-likes")
    for cmdlike in cmdlikes.values():
        cmdlike.resolve()


# TODO: refactor down some of this duplication (here and elsewhere)
# keeping it painfully explicit for now to make it easier to
# think/search between different cases here
class RecordCommandlike(object):
    solutions = word_objects = None

    def __init__(self):
        self.solutions = dict()
        self.word_objects = dict()

    @classmethod
    def disable_alias_replacement(cls):
        cls.record_alias_cmd = cls._disabled_recorder

    def _disabled_recorder(self, *args, **kwargs):
        pass

    def get_word_position(self, word_object, position=None):
        pos = position or word_.LeftMostSpanForWord(word_object)
        self.word_objects[pos] = word_object
        return pos

    def record_general_cmd(self, word_object, word_text, position=None):
        """Record command found in general namespace."""
        # This is where we have to act
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_full_solution(self)

    def record_alias_cmd(self, word_object, word_text, position=None):
        """Record command found in alias definition namespace."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_alias_solution(self)

    def record_builtin_cmd(self, word_object, word_text, position=None):
        """Record command argument to `builtin` builtin :)"""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_builtin_solution(self)

    def record_command_cmd(self, word_object, word_text, position=None):
        """Record command argument to `command` builtin."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_command_solution(self)

    def record_external_cmd(self, word_object, word_text, position=None):
        """Record command argument to commands known to run externals."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_external_solution(self)

    def record_external_source(
        self, word_object, word_text, replace_with=None, position=None
    ):
        """
        Record file argument to `source` builtin.

        CAUTION:
        This has the same basic effect as the others, but it uses
        slightly different logic. In short, the others are for queueing late
        resolution of each command-like. We *could* do that here--but we have
        to parse each source *before* we can late-resolve everything else
        correctly.

        So, in this one case, the caller is passing in the solution at call
        time. We still record the solutions, but instead of creating a
        CommandLike, we add it to resolved_source so that it's easy to parse
        each in a later step.
        """
        pos = self.get_word_position(word_object, position)
        sol = self.solutions[pos] = Solution()
        if replace_with:
            sol.replace_name_with(word_text, replace_with)
            self.resolved_source.add(replace_with)
        else:
            sol.no_change()
            self.resolved_source.add(word_text)


class ResolvedScript(RecordCommandlike):
    """
    Represent each individual script that we resolve.
    """

    # We need to extract more info after hitting some firstwords
    # This list is just for noticing if something is breaking expectations
    WATCH_FIRSTWORDS = {
        "sudo",
        "command",
        "eval",
        "exec",
        ".",
        "source",
        "alias",
        "env",
        "coproc",
    }

    @staticmethod
    def _make_parser(parse_ctx, script, arena):
        """
        Do the last few steps to make a file-specific parser.
        """
        return parse_ctx.MakeOshParser(reader.FileLineReader(script, arena))

    def replace_shebang(self, fileob, shebang=False):
        """
        - skip over the shebang lines, else raise
        - prepend new shebang if available
        """
        pos = fileob.tell()
        line = fileob.readline()

        while line[0:2] == "#!":
            if shebang is False:
                raise Exception(
                    "Oh gosh :( you gotta get this shebang looked at", line, pos
                )
            elif shebang or shebang is None:
                logger.debug("Skipping shebang line: %r", line)

            pos = fileob.tell()
            line = fileob.readline()

        logger.debug("First non-shebang line: %r", line)
        fileob.seek(pos)
        logger.debug("appending shebang: %r", shebang)
        return StringIO.StringIO((shebang if shebang else "") + fileob.read())

    def __init__(self, script_path=None, shebang="", prologue=None, epilogue=None):
        # generally, defer work until we know the script loaded
        with (open(script_path) if script_path else sys.stdin) as script:
            if shebang:  # not allow_shebang:
                script = self.replace_shebang(script, shebang)

            arena = alloc.Arena()
            parse_ctx = parse_lib.ParseContext(
                arena=arena,
                parse_opts=optview.Parse(NO_OPTIONS),
                aliases={},  # dummy
                oil_grammar=None,
            )
            parse_ctx.Init_OnePassParse(True)

            if script_path:
                # TODO: is there a real difference between using mainfile and
                # sourcedfile? (this gets re-used for sourced scripts)
                arena.PushSource(source.MainFile(script_path))
            else:
                arena.PushSource(source.Stdin())

            # set([ (scope, identifier), ... ])
            self.directives = ResolutionDirectives()
            self.parse_directives(script, script_path)

            try:
                node = main_loop.ParseWholeFile(
                    self._make_parser(parse_ctx, script, arena)
                )
            except error.Parse as e:
                e.arena = arena
                raise

        assert node is not None

        # actually initialize
        RecordCommandlike.__init__(self)
        self.arena = arena
        self.root = node
        self.prologue = prologue
        self.epilogue = epilogue

        self.resolved_source = set()  # ResolvedSource objects

        # "resolve"
        try:
            self.Visit(node)
            self.resolve_sources()
        except ResolutionError as e:
            e.print_if_needed()
            raise e

    def parse_directives(self, script, path):
        """
        read the tail of the file for directives;
        abort as soon as we find a nonmatching line

        # resholve: <type> scope:<identifier>
        """
        global directives
        path = path if path else "<stdin>"
        self.in_doc_directives = ResolutionDirectives()
        for line in script:
            if line.startswith("# resholve: "):
                try:
                    if line.startswith("# resholve: allow"):
                        raise InFileDirectiveError(
                            "While parsing resholve directives already in this "
                            "script, I encountered an 'allow' directive from "
                            "resholve(d)'s pre-history. The program no longer "
                            "supports this directive format--you'll have to "
                            "re-resholve this script with a modern version. ",
                            path,
                            line,
                        )
                    elif line.startswith("# resholve: fake"):
                        self.in_doc_directives.fake.update(
                            directive_fake(line[17:].strip())
                        )
                    elif line.startswith("# resholve: fix"):
                        self.in_doc_directives.fix.update(
                            directive_fix(line[16:].strip())
                        )
                    elif line.startswith("# resholve: keep"):
                        self.in_doc_directives.keep.update(
                            directive_keep(line[17:].strip())
                        )
                except argparse.ArgumentTypeError as e:
                    raise InFileDirectiveError(e.message, path, line)
            elif line.startswith(
                "### resholve directives (auto-generated) ## format_version: "
            ):
                # some modern version
                version = line[60:].strip()
                if version != DIRECTIVE_FORMAT:
                    logger.warning(
                        "resholve version {:} with *native* directive "
                        "fmt v{:} parsing directive fmt v{:}".format(
                            __version__, DIRECTIVE_FORMAT, version
                        )
                    )
                # TODO: haven't decided what we should do w/ mismatches
        script.seek(0)
        self.directives.update(self.in_doc_directives, directives)

    def write_directives(self, cursor):
        global DIRECTIVE_FORMAT
        template = "\n### {:} ## {:}: {:}\n"
        # we only want items that weren't already in the file
        if len(self.in_doc_directives) < len(self.directives):
            if len(self.in_doc_directives) == 0:
                cursor.f.write(
                    template.format(
                        "resholve directives (auto-generated)",
                        "format_version",
                        DIRECTIVE_FORMAT,
                    )
                )
            new_directives = self.directives.difference(self.in_doc_directives)
            cursor.f.writelines(
                [
                    self.write_directive(directive)
                    for directive in sorted(new_directives)
                ]
                + ["\n"]
            )

    @staticmethod
    def write_directive(directive):
        if len(directive) == 3:
            return "# resholve: {:} {:}:{:}\n".format(*directive)
        elif len(directive) == 2:
            return "# resholve: {:} {:}\n".format(*directive)

    def write_to(self, path=None):
        f = open(path, "w") if path else sys.stdout
        try:
            self.render(to=f)
        except ResolutionError as e:
            e.print_if_needed()
            raise e
        finally:
            f.close()

    def render(self, to=sys.stdout):
        cursor = osh2oil.Cursor(self.arena, to)

        replacements = sorted(self.solutions.keys())
        if len(replacements):
            logger.info("Making replacements")
            logger.debug("  The replacements are: %r", self.solutions)
            logger.debug("  They'll be made in this order: %r", replacements)

        # if the user has specified a prepend string, find the first
        # actual code span, so that we can inject before it.
        if self.prologue:
            first_span = 0

            first_node = self.root
            while True:
                if hasattr(first_node, "spids") and len(first_node.spids):
                    first_span = first_node.spids[0]
                    break
                if hasattr(first_node, "words"):
                    first_span = word_.LeftMostSpanForWord(first_node.words[0])
                    break
                first_node = first_node.children[0]

            assert first_span <= replacements[0], (
                "First identified code span (%r) is unexpectedly later than the first identified replacement (%r)."
                % (first_span, replacements[0])
            )

            cursor.PrintUntil(first_span)
            to.write("\n# begin prologue inserted by resholve\n")
            to.write(self.prologue.read())
            to.write("\n# end prologue inserted by resholve\n")
            cursor.PrintUntil(first_span + 1)

        for location in replacements:
            solution = self.solutions[location]

            e = solution.exception
            if solution.replacement:
                cursor.PrintUntil(location)

                span = self.arena.GetLineSpan(location)

                line = self.arena.GetLine(span.line_id)
                current = line[span.col : span.col + span.length]
                to.write(solution.replace_in(current))

                # we already wrote this one; leapfrog
                cursor.SkipUntil(location + 1)
            elif e:
                e.word = self.word_objects[location]
                e.span_id = location
                e.arena = self.arena
                raise e

        cursor.PrintUntil(self.arena.LastSpanId())

        if self.epilogue:
            to.write("\n# begin epilogue inserted by resholve\n")
            to.write(self.epilogue.read())
            to.write("\n# end epilogue inserted by resholve\n")

        self.write_directives(cursor)
        self.arena.PopSource()
        return self

    def resolve_sources(self):
        global resolved_scripts
        logger.info("Resolving sources")
        for res_source in self.resolved_source:
            if (
                res_source not in resolved_scripts
                and ("source", res_source) not in self.directives.fake
            ):
                logger.info("Parsing sourced script %r", res_source)
                resolved = self.__class__(res_source)
                resolved_scripts[res_source] = resolved
            self.directives.keep.add(
                (
                    "source",
                    res_source,
                )
            )

    def _visit_command_Simple(self, node):
        if not node.words:
            return

        w_ob1 = node.words[0]
        ok1, word1, _ = word_.StaticEval(w_ob1)
        if not ok1:
            for part in w_ob1.parts:
                bad_token = find_dynamic_token(part)
                if bad_token:
                    # number subs are probably okayish?
                    if bad_token.id in (Id.VSub_Number, Id.VSub_At, Id.VSub_Star):
                        logger.info(
                            "allowing dynamic command (first-word variable) with positional ($1, $@, $*) varsub %r:%r",
                            word1,
                            bad_token.val,
                        )
                        return
                    else:
                        # normalize across braced and unbraced subs
                        bad_token_name = None
                        if bad_token.id == Id.VSub_Name:
                            # add $ prefix
                            bad_token_name = "${:}".format(bad_token.val)
                        elif bad_token.id == Id.VSub_DollarName:
                            # it already has $ prefixed
                            bad_token_name = bad_token.val
                        elif bad_token.id == Id.Lit_TildeLike:
                            # try to get the text
                            # confidence in approach: medium
                            left, right = span_pair(w_ob1, self.arena)
                            line = self.arena.GetLine(left.line_id)
                            start = left.col
                            end = right.col + right.length
                            bad_token_name = line[start:end]

                        if (bad_token_name,) in self.directives.keep:
                            # skip exempted name
                            logger.info(
                                "allowing exempted dynamic command %r",
                                bad_token_name,
                            )
                            return

                        raise ResolutionError(
                            "Can't resolve dynamic command",
                            word=w_ob1,
                            token=bad_token,
                            status=9,
                            arena=self.arena,
                        )
            else:
                logger.debug(
                    "Couldn't statically evaluate 1st word object of command: %r", w_ob1
                )
                return
        else:
            self.record_general_cmd(w_ob1, word1)

        # If there's a second word, let's go ahead and prepare it.
        # We don't know we need it, but enough cases do that it's easier.
        if len(node.words) > 1:
            w_ob2 = node.words[1]
            ok2, word2, _ = word_.StaticEval(w_ob2)
            # we don't care if it succeeded, yet
        else:
            if word1 in self.WATCH_FIRSTWORDS:
                # just a chance to bail out on a broken script
                # may not be worth the code...
                raise Exception(
                    "Trying to handle {:} but it lacks a required argument".format(
                        word1
                    ),
                    node,
                )

        # CAUTION: some prefixable commands/builtins are ~infinitely nestable.
        # "builtin builtin builtin builtin builtin command whoami" is perfectly valid.
        # The current code won't see the dep on an external command 'whoami'.

        # TODO: Does it make sense to use the presence of builtin/command etc
        # as smells that trigger extra scrutinty? i.e., "builtin source" may
        # be a reasonable smell that the script or something it sources overrides
        # source?

        # TODO: should builtin be here? Currently not because we don't want to replace them...
        if word1 in self.WATCH_FIRSTWORDS:
            logger.info("Visiting command: %s %s", word1, word2)
            if word1 == "eval" and w_ob2.parts[0].tag in (
                word_part_e.SingleQuoted,
                word_part_e.DoubleQuoted,
            ):
                if EMIT_FEEDBACK_REQUESTS:
                    try:
                        raise FeedbackWantedWarning(
                            "Letting quoted %r through for now. Not sure if this is 'right' or not. Weigh in @ https://github.com/abathur/resholve/issues/2",
                            w_ob1.parts[0].val,
                            word=w_ob2,
                            status=66,
                            arena=self.arena,
                        )
                    except FeedbackWantedWarning:
                        pass
                return
            elif not ok2:
                logger.info("   Command is dynamic, %r", node)
                if word1 == "alias":
                    logger.debug("dynamic alias :( %r", node)
                    cmdlikes[word1].alias = True
                # DEBUG: print(node)
                for part in w_ob2.parts:
                    bad_token = find_dynamic_token(part)
                    if bad_token:
                        # Letting $1-style subs through for now.
                        #
                        # In practice, these could be paths we want to
                        # resolve, *or* be perfectly fine as is.
                        if bad_token.id in (Id.VSub_Number, Id.VSub_At, Id.VSub_Star):
                            logger.debug(
                                "allowing dynamic command with positional ($1, $@, $*) varsub %r:%r",
                                word1,
                                bad_token.val,
                            )
                            return
                        # TODO: practice below mostly considers part vars like
                        # $HOME/blah or $PREFIX/blah, but there are other
                        # patterns a more sophisticated version could address.
                        # At the moment those would need to be manually
                        # patched. I'd like to follow this definition back to
                        # the vardef and register it for substitution if it's
                        # a simple string, flatten here and reconsider.

                        # Letting ${name}-style subs through only if they're in
                        # a list of allowed names. (goal: require conscious
                        # exceptions, but make them easy to add)
                        elif (
                            bad_token.id == Id.VSub_Name
                            and (word1, bad_token.val) in self.directives.keep
                        ):
                            logger.debug(
                                "allowing dynamic command with exempted named ${varsub} %r:%r",
                                word1,
                                bad_token.val,
                            )
                            return
                        # Letting $name-style subs through only if they're in
                        # a list of allowed names. (goal: require conscious
                        # exceptions, but make them easy to add)
                        elif (
                            bad_token.id == Id.VSub_DollarName
                            # [1:] to leave off the $
                            and (word1, bad_token.val) in self.directives.keep
                        ):
                            logger.debug(
                                "allowing dynamic command with exempted named $varsub %r:%r",
                                word1,
                                bad_token.val[1:],
                            )
                            return
                        else:
                            raise ResolutionError(
                                "Can't resolve %r with a dynamic argument",
                                w_ob1.parts[0].val,
                                word=w_ob2,
                                token=bad_token,
                                status=6,
                                arena=self.arena,
                            )

                raise Exception(
                    "Not sure. I thought 'ok' was only False when we hit a dynamic token, but we just searched for a dynamic token and didn't find one. Reconsider everything you know.",
                    part,
                    w_ob2,
                )
            else:
                logger.info("   Command is static")
                # No magic
                if word1 in ("command", "eval", "coproc"):
                    # TODO: could skip command -p/-v/-V here, but that's
                    # a step down a slippery slope I don't want to take
                    # without some better ~command handler
                    # TODO: not absolutely certain about resolution order here
                    self.record_command_cmd(w_ob2, word2)
                elif word1 in ("sudo", "exec", "env"):
                    # TODO: not absolutely certain about resolution order here
                    self.record_external_cmd(w_ob2, word2)
                elif word1 in (".", "source"):
                    # CAUTION: in a multi-module library, we'll have to think very carefully about how to look up targets in order to parse them, but *avoid* translating the source statement into an absolute URI. (If this is sticky, another option might be a post-substitute to replace the build-path with the output path?)
                    target = None
                    if word2.startswith("/") and os.path.isabs(word2):
                        # Note: logic here tracks generate_external_resolver()
                        if ("source", word2) in self.directives.keep or (
                            ".",
                            word2,
                        ) in self.directives.keep:
                            # user said keep this abspath
                            self.record_external_source(w_ob2, word2)
                            target = False
                        elif ("source", word2,) in self.directives.fix or (
                            ".",
                            word2,
                        ) in self.directives.fix:
                            # user said to resolve this abspath as if it were bare
                            relword2 = os.path.basename(word2)
                            target = lookup_source(relword2)
                            logger.debug(
                                "Looked up source: %r -> %r -> %r",
                                word2,
                                relword2,
                                target,
                            )
                        else:
                            # TODO: better message
                            raise ResolutionError(
                                "Unexpected absolute source path (not supplied by a listed dependency). You should patch/substitute it.",
                                word=w_ob2,
                                status=5,
                                arena=self.arena,
                            )
                    else:
                        target = lookup_source(word2)
                        logger.debug("Looked up source: %r -> %r", word2, target)

                    # it was already a valid absolute path
                    if target:
                        # lookup() seems to resolve relative filenames for files in the
                        # current directory, no matter what path is set to...
                        if target == word2:
                            # TODO: I guess these all need to get prefxed with $out?
                            # TODO: be skeptical of this
                            self.record_external_source(w_ob2, word2)
                        # it resolved to a new location
                        elif target:
                            self.record_external_source(
                                w_ob2, word2, replace_with=target
                            )
                    # It didn't resolve, or it was an invalid absolute path
                    elif target != False:
                        # in theory I could pass this exception to the new
                        # self.record_external_source, but this would mean we can't
                        # fail as soon. Failing soon seems better, no?
                        raise ResolutionError(
                            "Unable to resolve source target %r to a known file",
                            word2,
                            word=w_ob2,
                            status=7,
                            arena=self.arena,
                        )
                # TODO: there may a generalized handler for "varlikes" here, which
                # oil defines as <id>=<stuff> but I'll say is more like:
                # [<alias|declare|local|set>] [<<id>=<val>>...]
                elif word1 == "alias":
                    # TODO: past time to extract some of these subtrees
                    # into function so we can just call self.visit_alias(node)
                    # or whatever. But do it in a single refactor--not now.
                    #
                    # aliases seem simple at a blush, but the defs
                    # can also be very complex...
                    # alias a=b a="b" a='b' "a=b" 'a=b' a=$b a="$b" a='$b' "a=$b" 'a=$b' 'a=echo $b', etc.
                    #
                    # code is ~v2 of trying to handle aliases.
                    # - v1: try to spot alias identifiers to add to
                    #   allowed unresolved "commands"
                    #   # TODO: make sure the code's check order is aliases > functions > externals
                    # - v2: try to extract alias/expansion pairs to
                    #   - allow unresolved commands
                    #   - make users triage externals in low-hanging-fruit
                    #     alias definitions (resolve? ignore?)
                    #   - TODO: do anything else with high-hanging fruit?
                    logger.debug("alias node: %r", node)

                    for w_ob in node.words[1:]:
                        w_ok, w_text, _ = word_.StaticEval(w_ob)
                        # TODO: for reasons I don't quite understand yet strings w/
                        # varsubs pass static eval here; may have to unwrap them first?
                        logger.debug(
                            "alias (ok? %r) split %r",
                            w_ok,
                            w_text.strip("\"='").split("="),
                        )
                        if w_ok:
                            # not dynamic
                            # example values from tests/aliases.sh:
                            # 'a', 'echo'
                            # 'b', 'ls'
                            # 'c', 'echo blah'
                            # 'c1', 'echo blah'
                            # 'd', 'echo $SOURCE_DATE_EPOCH'
                            # 'd1', 'echo $SOURCE_DATE_EPOCH'
                            # 'e', 'a'
                            # 'f', 'b'
                            # 'g', 'have_fun'
                            # 'h', 'delay_definition'
                            alias, definition = w_text.strip("\"='").split("=")
                            # TODO: maybe below deserves an explicit API
                            cmdlikes[alias].alias = True
                            commandlike = definition.split()[0]

                            pos = None

                            # Finding pos is a little tricky, so annotating the logic
                            # if the alias word has 2 parts, and the 2nd part is a token
                            #     pos = the 2nd part's span_id
                            # else
                            #     *so far* it seems like pos is always
                            #     the spid of the last part's first token OR part
                            if (
                                w_ob.parts
                                and len(w_ob.parts) == 2
                                and w_ob.parts[1]
                                and isinstance(w_ob.parts[1], Token)
                            ):
                                logger.debug(
                                    "in any case, %r has a span_id of %r",
                                    w_ob.parts[1],
                                    w_ob.parts[1].span_id,
                                )
                                pos = w_ob.parts[1].span_id
                            else:
                                trg = w_ob.parts[-1]
                                logger.debug(
                                    "it should be the second spid of the last part; %r has a span_id of %r",
                                    trg,
                                    trg.tokens[0].span_id
                                    if hasattr(trg, "tokens")
                                    else trg.parts[0].span_id,
                                )
                                pos = (
                                    trg.tokens[0].span_id
                                    if hasattr(trg, "tokens")
                                    else trg.parts[0].span_id
                                )

                            self.record_alias_cmd(w_ob, commandlike, pos)
                        else:
                            raise ResolutionError(
                                "As far as I can tell, this just won't happen %r :]",
                                word2,
                                word=w_ob2,
                                status=8,
                                arena=self.arena,
                            )

    def _visit_command_ShFunction(self, node):
        cmdlikes[node.name].function = True

    def _Visit(self, node):
        cls = node.__class__
        # TODO: maybe a custom loglevel for this? It's useful, but
        # very situational and very spammy (especially on very large
        # scripts). For now, just uncomment as needed...
        # logger.debug("Visiting node %r (class: %r)", node, cls)
        if cls is command.Simple:
            self._visit_command_Simple(node)

        elif cls is command.ShFunction:
            self._visit_command_ShFunction(node)

    def Visit(self, node):
        self._Visit(node)
        self.VisitChildren(node)

    # borrowed from Visitor in tools/deps.py
    # seems like a lot to import for...
    def VisitChildren(self, node):
        """
        Args:
          node: an ASDL node.
        """

        for name in node.__slots__:
            child = getattr(node, name)
            if isinstance(child, list):
                for item in child:
                    if isinstance(item, pybase.CompoundObj):
                        self.Visit(item)
                continue

            if isinstance(child, pybase.CompoundObj):
                self.Visit(child)
                continue


if __name__ == "__main__":
    # punshow()  # DEBUG: toggle comments here when you want exceptions
    sys.exit(punshow())
