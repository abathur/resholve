#!/usr/bin/env python2
from __future__ import print_function

__version__ = "@version@"
__version_info__ = (x for x in __version__.split("."))
DIRECTIVE_FORMAT = "2"

import sys
import os
import StringIO
import io
import copy
import re
import csv

from subprocess import Popen, PIPE
from contextlib import contextmanager, nested

import configargparse as argparse
import logging

from collections import defaultdict, Iterable

logger = logging.getLogger(__name__)
logging.basicConfig(level=os.environ.get("LOGLEVEL", logging.WARNING))
# logging.basicConfig(filename='example.log', filemode='w', level=logging.DEBUG)

"""
NOTE:
All of the below are imports from/for oil. Try to keep careful notes
on what is used from each Oil module. Oil is still young.
It's easier to track upstream reorg w/ succinct notes.
"""

# NOTE: not from oil, but just to support a rewritten variant
# of oil code (find_dynamic_token)
from typing import cast  # only in find_dynamic_token
from oil.mycpp.mylib import tagswitch  # only in find_dynamic_token

from oil.asdl import pybase  # CompoundObj

from oil.core import alloc  # Arena
from oil.core import error  # Parse, _ErrorWithLocation
from oil.core import main_loop  # ParseWholeFile
from oil.core import optview  # Parse
from oil.core import state  # InitOpts
from oil.core import ui  # PrettyPrintError

from oil.osh import word_  # LeftMostSpanForWord, RightMostSpanForWord StaticEval
from oil.osh import split  # SplitContext
from oil.osh import word_eval  # CompletionWordEvaluator, StringWordEvaluator
from oil.osh import sh_expr_eval  # ArithEvaluator

# LookupSpecialBuiltin, LookupAssignBuiltin, LookupNormalBuiltin, NO_INDEX
from oil.frontend import consts
from oil.frontend import parse_lib  # ParseContext
from oil.frontend import reader  # FileLineReader

from oil._devbuild.gen.id_kind_asdl import Id  # VSub_Number, VSub_Name, VSub_DollarName

from oil._devbuild.gen.syntax_asdl import (
    source,  # MainFile, Stdin
    word_part_e,  # ArithSub, AssocArrayLiteral, BracedVarSub, CommandSub, DoubleQuoted, EscapedLiteral, ExtGlob, Literal, ShArrayLiteral, SimpleVarSub, SingleQuoted, Splice, TildeSub
    command,  # ShFunction, Simple
    double_quoted,  # directly for cast()
    Token,  # directly for cast(), also for alias parsing
)

from oil.tools import osh2oil  # Cursor


def span_pair(word_object, arena):
    return (
        arena.GetLineSpan(word_.LeftMostSpanForWord(word_object)),
        arena.GetLineSpan(word_.RightMostSpanForWord(word_object)),
    )


def get_token_len(token):
    return len(token.val)


def get_part_len(part):
    if part.tag == word_part_e.CommandSub:
        # skip the part itself, but assume it eats up 18 chars
        # for "__NO_COMMAND_SUB__" (because Eval* replaces c_sub
        # with this)
        return 18
    elif part.tag == word_part_e.DoubleQuoted:
        total = len(part.left.val)
        for subpart in part.parts:
            total += get_part_len(subpart)
        return total
    elif part.tag == word_part_e.SingleQuoted:
        total = len(part.left.val)
        for token in part.tokens:
            logger.debug("len token", token)
            total += get_token_len(token)
        return total
    elif hasattr(part, "val"):
        return len(part.val)
    elif hasattr(part, "token"):
        return get_token_len(part.token)
    elif hasattr(part, "parts"):
        total = 0
        for subpart in part.parts:
            total += get_part_len(subpart)
        return total
    raise Exception(part, dir(part))


def get_word_len(word):
    total = 0
    for part in word.parts:
        total += get_part_len(part)

    if total == 0:
        raise Exception()
    return total


def get_next_val(word):
    start = cur = word
    while hasattr(cur, "parts"):
        cur = cur.parts[0]
    if hasattr(cur, "val"):
        return cur.val
    elif hasattr(cur, "token"):
        return cur.token.val


class ResolutionDirectives(object):
    fake = fix = keep = None

    def __init__(self, fake=None, fix=None, keep=None):
        self.fake = fake or set()
        self.fix = fix or set()
        self.keep = keep or set()

    def __len__(self):
        return len(self.fake) + len(self.fix) + len(self.keep)

    def update(self, *peers):
        for peer in peers:
            assert isinstance(peer, ResolutionDirectives)
            self.fake.update(peer.fake)
            self.fix.update(peer.fix)
            self.keep.update(peer.keep)

    @staticmethod
    def _type_tuple(type, entry):
        if len(entry) == 1:
            return (type, entry[0])
        if len(entry) == 2:
            return (type, entry[0], entry[1])

    def difference(self, *peers):
        out = set()
        for peer in peers:
            assert isinstance(peer, ResolutionDirectives)
            for fake in self.fake.difference(peer.fake):
                out.add((self._type_tuple("fake", fake)))
            for fix in self.fix.difference(peer.fix):
                out.add((self._type_tuple("fix", fix)))
            for keep in self.keep.difference(peer.keep):
                out.add((self._type_tuple("keep", keep)))

        return out

    def relevant(self, name):
        def rel_filt(val):
            if len(val) == 1:
                return name == val[0]
            if len(val) == 2:
                return name == val[1]

        return self.__class__(
            fake=filter(rel_filt, self.fake),
            fix=filter(rel_filt, self.fix),
            keep=filter(rel_filt, self.keep),
        )


directives = ResolutionDirectives()


def parse_directive(value, scope_map=None):
    if not len(value):
        return None
    out = set()
    try:
        directives = value.split(" ")
        logger.debug("directives: %r", directives)
        for directive in directives:
            rules = directive.split(":", 1)
            if len(rules) == 1:
                out.add((rules[0],))
                continue
            elif len(rules) == 2:
                scope = rules[0] if not scope_map else scope_map(rules[0])
                rules = rules[1]
                rules = rules.split(";")
                for rule in rules:
                    out.add((scope, rule))
            else:
                raise argparse.ArgumentTypeError(
                    "Directives may not have more than one colon: %r" % directive
                )
    except ValueError as e:
        raise argparse.ArgumentTypeError(
            "I don't recognize %r as a known directive. See 'man resholve'." % value
        )
    return out


FAKE_DIRECTIVE_MAP = {
    "a": "alias",
    "b": "builtin",
    "e": "external",
    "f": "function",
    "k": "keyword",
    "s": "source",
}
FAKE_DIRECTIVE_TYPES = set(FAKE_DIRECTIVE_MAP.keys()) | set(FAKE_DIRECTIVE_MAP.values())


def remap_fake_scope(scope):
    global FAKE_DIRECTIVE_MAP
    if scope in FAKE_DIRECTIVE_MAP:
        return FAKE_DIRECTIVE_MAP[scope]
    else:
        return scope


def directive_fake(value):
    global FAKE_DIRECTIVE_TYPES
    directives = parse_directive(value, remap_fake_scope)
    if not directives:
        return None
    for directive in directives:
        if len(directive) == 1:
            raise argparse.ArgumentTypeError(
                "valid fake directives must have at least two parts"
            )
        elif directive[0] not in FAKE_DIRECTIVE_TYPES:
            raise argparse.ArgumentTypeError(
                "fake directive type (%r) is not one of %r"
                % (directive[0], FAKE_DIRECTIVE_TYPES)
            )

    return directives


def directive_fix(value):
    directives = parse_directive(value)
    if not directives:
        return None
    logger.debug("validating fix directives %r", directives)
    for directive in directives:
        if len(directive) == 1:
            logger.debug("%r %r", directive[0], directive[0] == "aliases")
            if directive[0] == "aliases":
                pass  # ok literal
            elif os.path.isabs(directive[0]):
                pass  # ok absolute path
            else:
                raise argparse.ArgumentTypeError(
                    "valid single-part fix directives: 'aliases', absolute path"
                )
        elif len(directive) == 2:
            # we can't validate $variable or outer_command before parse
            # but we can pre-validate command lookup for the target
            target = lookup(directive[1])
            if not target:
                raise argparse.ArgumentTypeError(
                    "I couldn't resolve '{command}' in directive {scope}:{command}".format(
                        scope=directive[0], command=directive[1]
                    )
                )
    return directives


def directive_keep(value):
    directives = parse_directive(value)
    if not directives:
        return None
    logger.debug("validating keep directives %r", directives)
    for directive in directives:
        if len(directive) == 1:
            if directive[0][0] == "$":
                pass  # ok literal
            elif directive[0][0:2] == "~/" and os.path.isabs(
                os.path.expanduser(directive[0])
            ):
                pass
            elif os.path.isabs(directive[0]):
                pass  # ok absolute path
            else:
                raise argparse.ArgumentTypeError(
                    "valid single-part keep directives: $variable, absolute path, ~/path"
                )
        elif len(directive) == 2:
            pass
            # can't do much to pre-validate these
    return directives


def interpreter_to_shebang(interp):
    if interp == "none":
        return None

    if not os.path.exists(interp):
        raise argparse.ArgumentTypeError(
            "Interpreter must exist or be the string 'none'"
        )

    if not os.path.isabs(interp):
        raise argparse.ArgumentTypeError("Interpreter path must be absolute")

    if not os.access(interp, os.X_OK):
        raise argparse.ArgumentTypeError("Interpreter must be executable")

    return "#!{:}\n".format(interp)


class SuperSerial(csv.Dialect):
    """
    I'm using the unit separator for field separating but keeping \n
    for row/record separation for now. I realize that's a little
    inconsistent, but I feel like it's a good tradeoff between the
    chance that the serialization format has to handle an executable
    with the unit separator included, and keeping the format humane to
    write/script when where/needed.
    """

    delimiter = ":"
    escapechar = str("\x1f")  # https://en.wikipedia.org/wiki/Unit_separator
    quotechar = None
    doublequote = False
    skipinitialspace = False
    lineterminator = "\n"
    quoting = csv.QUOTE_NONE


csv.register_dialect("superserial", SuperSerial)


class LoreType(object):
    """
    Type for working with a "lore" directory.
    """

    lore_kinds = None

    @staticmethod
    def reader(f, fields):
        return csv.DictReader(
            f,
            fields,
            dialect="superserial",
        )

    @staticmethod
    def execers(f):
        return LoreType.reader(
            f,
            [
                "verdict",  # can|cannot|might
                "executable",  # abspath
            ],
        )

    @staticmethod
    def wrappers(f):
        return LoreType.reader(
            f,
            [
                "wrapper",  # abspath
                "wrapped",  # abspath
            ],
        )

    def __init__(self, lore_kinds):
        """ """
        self.lore_kinds = lore_kinds

    # TODO: see if you can fold ingest_lore in for better
    #       invocation-time argparse errors

    def __call__(self, value):
        if len(self.lore_kinds) == 1:
            return self._call_str(value)
        else:
            return self._call_dir(value)

    def _call_str(self, value):
        try:
            for kind in self.lore_kinds:
                reader = getattr(self, kind)
                return list(reader(value.split()))
        except Exception as e:
            raise argparse.ArgumentTypeError(
                "%s must be a colon-delimited string. Got: %r"
                % (self.lore_kinds[0], value)
            )

    def _call_file(self, path):
        try:
            if os.path.exists(path) and not os.path.isdir(path):
                for kind in self.lore_kinds:
                    f = open(path)
                    reader = getattr(self, kind)
                    return reader(f)
            else:
                raise Exception("%s is not a file" % path)
        except Exception as e:
            raise argparse.ArgumentTypeError(
                "%s\n lore must be a single file. %s" % (self.lore_kinds[0], e)
            )

    def _call_dir(self, path):
        try:
            if os.path.isdir(path):
                files = dict()

                for kind in self.lore_kinds:
                    f = open("{:}/{:}".format(path, kind))
                    reader = getattr(self, kind)
                    files[kind] = reader(f)
                return files
            else:
                raise Exception("%s is not a directory" % path)
        except Exception as e:
            raise argparse.ArgumentTypeError(
                "%s\nLore must be a "
                "directory with a file named "
                "'execers' (and optionally one named "
                "'wrappers')." % e
            )


class Accumulate(argparse.Action):
    def __call__(self, _parser, ns, vals, *args):
        setattr(ns, self.dest, (getattr(ns, self.dest) or []) + vals)


lookup = None


class LookSee(dict):
    """
    A dictionary for input (~PATH) lookups.

    Broad strokes:
    - Take ownership of lookup from distutils.spawn.find_executable to
      stop matching files in the current PWD (explicit > implicit) and
      avoid having to set PATH.
    - Support both directories and individual files in the ~PATH.
      - Pre-cache files and rm from search path
      - Lazily lookup and cache others
    """

    paths = None
    __call__ = dict.__getitem__

    def __init__(self, path):
        """
        init from path-fmt string
        - comes via --path/--inputs or RESHOLVE_(PATH|INPUTS)
        - each element may be a dir or file
        """
        dict.__init__(self)
        paths = set()
        for path in set(path.split(os.pathsep)):
            if os.path.isfile(path):
                self[os.path.basename(path)] = path
            else:
                paths.add(path)
        self.paths = paths

    def __missing__(self, basename):
        """
        Return abspath or None
        """
        for path in self.paths:
            abspath = os.path.join(path, basename)
            if os.path.isfile(abspath):
                return abspath
        return None


def make_arg_parser(module):
    parser = module.ArgumentParser(
        description="Resolve external command/script references in a shell script to absolute paths. This is a terse reminder of flag names; see 'man resholve' for usage.",
        usage="resholve [options] script ...",
        auto_env_var_prefix="RESHOLVE_",
        add_env_var_help=False,
        add_help=False,
    )
    parser.register("action", "accumulate", Accumulate)

    req = parser.add_argument_group(
        title="Required",
    )
    req_path = req.add_mutually_exclusive_group(required=True)

    req.add_argument(
        "scripts",
        metavar="script",
        type=str,
        nargs="*",
        help="script paths to resolve",
    )
    req_path.add_argument(
        "--path",
        metavar="str",
        dest="path",
        type=LookSee,
        help="paths to resolve commands from",
    )
    req_path.add_argument(
        "--inputs",
        metavar="str",
        dest="path",
        type=LookSee,
        help="alias for --path",
    )

    req.add_argument(
        "--interpreter",
        dest="shebang",
        type=interpreter_to_shebang,
        metavar="p",
        help="specify interpreter for shebang; does NOT otherwise impact how resholve interprets a script",
        required=True,
    )

    res = parser.add_argument_group(
        title="Controlling resolution",
    )

    res.add_argument(
        "--fake",
        metavar="str",
        action="append",
        type=directive_fake,
        help="pretend some commands exist",
    )
    res.add_argument(
        "--fix",
        metavar="str",
        action="append",
        type=directive_fix,
        help="fix things we can't auto-fix/ignore",
    )
    res.add_argument(
        "--keep",
        metavar="str",
        action="append",
        type=directive_keep,
        help="keep things we can't auto-fix/ignore",
    )
    """
    TODO: disabling some options that I sketched out but that
    do not square with the current implementation and may not
    be necessary. Can probably dump if still here in 2022.

    res.add_argument(
        "--oracle",
        dest="oracle",
        metavar="str",
        action="append",
        type=str,
        help="executable...",
    )
    res.add_argument(
        "--assayer",
        dest="assayer",
        metavar="str",
        action="append",
        type=str,
        help="executable...",
    )
    """
    res.add_argument(
        "--lore",
        type=LoreType(("execers", "wrappers")),
        metavar="d",
        help="lore directory",
    )
    res.add_argument(
        "--execer",
        type=LoreType(("execers",)),
        metavar="str",
        action="accumulate",
        help="single execer directive",
    )
    res.add_argument(
        "--wrapper",
        type=LoreType(("wrappers",)),
        metavar="str",
        action="accumulate",
        help="single wrapper directive",
    )
    res.add_argument(
        "--assay",
        type=argparse.FileType("r"),
        metavar="f",
        # see tests for usage; not "supported; unsure.
        help=argparse.SUPPRESS,
    )

    other = parser.add_argument_group(title="Other")

    other.add_argument(
        "--prologue",
        type=argparse.FileType("r"),
        metavar="f",
        help="insert file before resolved script",
    )
    other.add_argument(
        "--epilogue",
        type=argparse.FileType("r"),
        metavar="f",
        help="insert file after resolved script",
    )

    other.add_argument(
        "--overwrite",
        action="store_true",
        dest="overwrite",
        help="Replace script files instead of writing to script.resolved.",
    )
    # other.add_argument(
    #     "--faff", type=int, metavar="int", help="fuzz n times for missed commands",
    # )
    meta = parser.add_argument_group(title="Meta")
    meta.add_argument(
        "-h", "--help", action="help", help="show this help message and exit"
    )
    meta.add_argument(
        "--version",
        action="version",
        version="%(prog)s {:}".format(__version__),
    )

    return parser


parser = make_arg_parser(argparse)

resolved_scripts = dict()


def resolve_script(script_path, shebang="", prologue=None, epilogue=None):
    if script_path in resolved_scripts:
        return resolved_scripts[script_path]

    resolved = resolved_scripts[script_path] = ResolvedScript(
        script_path, shebang=shebang, prologue=prologue, epilogue=epilogue
    )
    return resolved


def write_resolved_script(script_path, resolved, overwrite=False):
    if not script_path:
        resolved.write_to()
    elif overwrite:
        logger.info("attempting to overwrite script %r", script_path)
        resolved.write_to(script_path)
        sys.stderr.write("Overwrote %r\n" % (script_path))
    else:
        logger.info(
            "overwrite not set; will attempt to write to: %s%s",
            script_path,
            ".resolved",
        )
        resolved.write_to(script_path + ".resolved")
        sys.stderr.write(
            "Rewrote %r to %r\n" % (script_path, script_path + ".resolved")
        )


def lookup_source(word):
    """
    wrap lookup(word) to special-case source lookups

    lookup can't resolve something like `source submodule/helper.sh`
    unless we add subdirs to PATH, but that could let all kinds of
    stuff into the resolution scope.

    Instead, we'll try to resolve source calls from the list of
    input scripts before giving lookup a chance.

    This is a little weird, but this is a not-implemented stub for
    documentation. The business-end of this function is temporarily
    published the sourcePATH() context manager during punshow()
    """
    raise NotImplementedError("lookup_source called outside of sourcePATH context")


@contextmanager
def sourcePATH(script_map):
    global lookup_source

    def contextual_lookup_source(word):
        if word in script_map:
            logger.debug("source in script map %r -> %r", word, script_map)
            return script_map[word]
        logger.debug("source not in script map %r", word)
        return lookup(word)

    prev = lookup_source
    lookup_source = contextual_lookup_source
    yield
    lookup_source = prev


lore = dict()
decided_execers = defaultdict(dict)


def ingest_lore(lorefiles):
    global lore
    logger.debug("ingesting lore %r", lorefiles)
    logger.debug("ingesting lore:execers %r", lorefiles["execers"])
    for row in lorefiles["execers"]:
        logger.debug("ingesting lore:execers:row %r", row)
        try:
            lore[row["executable"]] = row["verdict"]
        except Exception as e:
            raise Exception(row, lore, e)

    if "wrappers" not in lorefiles:
        return

    for row in lorefiles["wrappers"]:
        if row["wrapped"] in lore:
            # overwrite the wrapper's verdict with the wrapped executable's
            lore[row["wrapper"]] = lore[row["wrapped"]]


def ingest_assay(assayfile):
    reader = csv.DictReader(
        # TODO: If the general practice sticks, I may move cmd to end because
        # the separator is now ":", and it'll be easier to adapt to colons in
        # invocations if we can eat 3 colons and call the rest the command.
        assayfile,
        [
            "executable",  # abspath
            "command",  # ~basename $@
            "verdict",  # yes|no|unknown
            # positions 0-indexed
            # let's try to work at the word level first?
            "wordnum",
        ],
        dialect="superserial",
    )

    for row in reader:
        logger.debug("assay ingest %r", row)
        if row["wordnum"] == "0":
            # TODO this needs to be fixed somehow; argparse
            # won't catch so it'll throw a stack AND exit 1
            raise argparse.ArgumentTypeError(
                "assay wordnum should be 1+ (0 is the same as the invoking command itself)"
            )

        decided_execers[row["command"].split()[0]] = {k: v for k, v in row.items()}


"""
I drafted the regex mechanism for subcommand resolution here
before I built out the AST-based functions that I'm using for
most commands. My rough intent/process at the time was to
explore the possibility that regex would be a workable model
for users to extend resholve's command support in a way that
meets their own immediate needs *and* which they can readily
upstream for our use here.

In practice, I found this approach works for commands where
subcommands follow specific flags in a predictable manner,
but that it is a nightmare for the more-common kind of sub-
executing command that accepts a number of flags/options
which themselves may or may not have arguments--all of which
we must be able to ignore--before we ultimately take the 1st
surviving positional arg.

Because of this, I have yet to settle on any end-user way to
provide information resholve can use to *globally* answer
this question (but see the --assay option for a per-case
option).

I suspect I'll eventually cut this implementation, but for
now, I'm leaving `find` here to make sure the it won't rot
between now and whenever I find a better approach.
Jun 2021
"""
# TODO: \s+ is probably appropriate in many of the places you have single spaces here, but I assume it'll also cause some lookbehind issues; KISS for now
subcommand_re = {
    # Caution: adding builtins here is almost certainly wrong;
    # they have differing contextual resolution rules!
    # coreutils
    # "sort": re.compile(
    #     r"(?<=sort ).*?(?:--compress-program (?P<resolve>['][^']*[']|[\"][^\"]*[\"]|\S*)).*"
    # findutils
    "find": re.compile(
        r"(?<=find ).*(?:-(ok|exec)(dir)? )(?P<resolve>.*?)(?=\s*[;+]\s*)"
    ),
}

"""
I'm not planning to use these builtins after realizing they'd have to
be functions--but they're a start towards documenting the regex format
and idioms that will be common for external commands matched this way.

I'll keep them here as a reference at least until there are enough
external commands to crib from.

unused_builtin_subcommand_re = {
    "builtin": re.compile(r"(?<=builtin )(?P<resolve>.*)"),
    "coproc": re.compile(r"(?<=coproc )(?P<resolve>.*)"),
    "command": re.compile(r"(?<=command (?!-(v|V) ))(?:-p )?(?P<resolve>.*)"),
    "eval": re.compile(r"(?<=eval )(?P<resolve>.*)"),
    # -a is probably wrong if NAME can be quoted?
    "exec": re.compile(r"(?<=exec )(?:-(c|l|a \S+) )?(?P<resolve>.*)"),
}
"""


def punshow():
    global lookup
    args = parser.parse_args()
    # if it makes sense at some point, vars(args) yields a dict of these
    # that can be passed as kwargs or something...
    logger.info("argparsed: %r", args)
    logger.debug("argument sources: \n%s", parser.format_values())

    # adopt the runtime dependency path for resolving external executables
    if args.path is None:
        # made this not-required in order to support both "path" and
        # "inputs" terminology (inputs is more nix-idiomatic) but
        # store in a single dest; fake our own error
        parser.error(
            "argument --path/--inputs (or RESHOLVE_PATH/RESHOLVE_INPUTS) is required"
        )

    lookup = args.path

    if args.fake:
        for group in args.fake:
            directives.fake.update(group)

    if args.fix:
        for group in args.fix:
            directives.fix.update(group)

    if args.keep:
        for group in args.keep:
            directives.keep.update(group)

    if args.lore:
        ingest_lore(args.lore)
        global lore
        logger.debug("lore: %r", lore)

    if args.execer or args.wrapper:
        ingest_lore(
            {
                "execers": args.execer if args.execer else tuple(),
                "wrappers": args.wrapper if args.wrapper else tuple(),
            }
        )

    if args.assay:
        ingest_assay(args.assay)

    if ("aliases",) not in directives.fix:
        RecordCommandlike.disable_alias_replacement()

    try:
        to_write = set()
        if len(args.scripts) == 0:
            # None == <stdin>
            with sourcePATH(dict()):
                resolved_scripts[None] = ResolvedScript(
                    shebang=args.shebang,
                    prologue=args.prologue,
                    epilogue=args.epilogue,
                )
                to_write.add(None)

        checked_scripts = list()
        script_map = dict()
        for in_script in args.scripts:
            abs_script = os.path.abspath(in_script)
            if os.path.exists(abs_script):
                checked_scripts.append(abs_script)
                script_map[in_script] = abs_script
            else:
                sys.stderr.write("Aborting due to missing file: %r\n" % abs_script)
                return 2

        if len(set(checked_scripts)) != len(checked_scripts):
            sys.stderr.write(
                "Aborting due to duplicate script targets.\n"
                "Verify your inputs and try again.\n"
            )
            sys.stderr.write("  Original: %r\n" % args.scripts)
            sys.stderr.write("  Distinct: %r\n" % set(checked_scripts))
            return 2

        with sourcePATH(script_map):
            for script in checked_scripts:
                resolve_script(
                    script,
                    shebang=args.shebang,
                    prologue=args.prologue,
                    epilogue=args.epilogue,
                )
                to_write.add(script)

        # cmdlikes are cross-source; try to resolve a single time
        # with one big asterisk: all builtins that *might* lead to a
        # source/alias during the first pass should be handled during
        # resolve_script()
        resolve_cmdlikes()

        for script_path in to_write:
            write_resolved_script(
                script_path, resolved_scripts[script_path], args.overwrite
            )

    except IOError as e:
        sys.stderr.write("Whoooo buddy: " + str(e))
        return 2
    except Forbid as e:
        e.print_if_needed()
        return e.exit_status
    except error._ErrorWithLocation as e:
        if hasattr(e, "print_if_needed"):
            e.print_if_needed()
        elif hasattr(e, "arena"):
            ui.PrettyPrintError(e, e.arena, getattr(e, "label", "error: "))
        else:
            print(
                "This error has location context I couldn't "
                "figure out how to print. Please report this "
                "@ https://github.com/abathur/resholve/issues",
                repr(e),
            )
        if hasattr(e, "exit_status") and e.exit_status is not None:
            return e.exit_status
        else:
            return 2
    except InFileDirectiveError as e:
        sys.stderr.write(str(e))
        return 2
    except argparse.ArgumentTypeError as e:
        sys.stderr.write("Hold up there, cowpoke: " + str(e))
        return 2


def find_earliest_spid(node):
    """
    I'll focus on the goal rather than mislead you with assertions about
    what this does (I'm not confident I understand all of the underlying
    variation within oil on this point).

    The old assumption was that, when a node has an spids list, the first
    item in the list is the earliest spid under the umbrella. That is
    usually true, and has held water for many months, but I've found at
    least one case with command.AndOr nodes where the leftmost spid in
    this array is actually for the && or || token.

    We really do want the earliest spid, because we want to be able to
    inject a prologue at that point. So, we'll try to descend the ~edge
    of the AST, keeping the lowest spid we find.
    """
    node_spid = sub_spid = None
    if hasattr(node, "spids") and node.spids and len(node.spids):
        node_spid = node.spids[0]
    elif hasattr(node, "span_id"):
        node_spid = node.span_id

    if hasattr(node, "children"):
        sub_spid = find_earliest_spid(node.children[0])
    elif hasattr(node, "words"):
        sub_spid = find_earliest_spid(node.words[0])
    elif hasattr(node, "parts"):
        sub_spid = find_earliest_spid(node.parts[0])

    # min will return a None, so fail down the list just in case
    return min(node_spid, sub_spid) or node_spid or sub_spid


def find_dynamic_token(part):
    # type: (word_part_t) -> token|bool
    """Recursive search for dynamic token.

    This is patterned on oil's word_._EvalWordPart, but with
    roughly inverted boolean logic: it returns the token object
    if one is found, otherwise False.
    """
    UP_part = part
    with tagswitch(part) as case:
        if case(word_part_e.ShArrayLiteral):
            return cast(Token, UP_part).token

        elif case(word_part_e.AssocArrayLiteral):
            return cast(Token, UP_part).token

        elif case(word_part_e.Literal):
            return False

        elif case(word_part_e.EscapedLiteral):
            return False

        elif case(word_part_e.SingleQuoted):
            return False

        elif case(word_part_e.DoubleQuoted):
            part = cast(double_quoted, UP_part)
            for p in part.parts:
                tok = find_dynamic_token(p)
                if tok:
                    return tok

            return False
        elif case(word_part_e.CommandSub):
            return cast(Token, UP_part).left_token

        elif case(
            word_part_e.SimpleVarSub,
            word_part_e.BracedVarSub,
            word_part_e.TildeSub,
            word_part_e.ArithSub,
            word_part_e.ExtGlob,
            word_part_e.Splice,
        ):
            return cast(Token, UP_part).token
        else:
            raise AssertionError(part.tag_())


# For optview.Parse. Oil does [False] * option_i.ARRAY_SIZE and
# [None] * option_i.ARRAY_SIZE; we'll cheat
class NoneListFake(object):
    def __getitem__(self, option):
        return None


NO_OPTIONS_OVERLAY = NoneListFake()


class ExceptionWithContext(error._ErrorWithLocation):
    pass


# label? code? issue? feedback? url?
class ResolutionException(ExceptionWithContext):
    """
    mostly same code for all 3 resolution exceptions
    """

    REPO = "https://github.com/abathur/resholve"
    ISSUES = "{:}/issues".format(REPO)
    SA_TEMPL = "{e.ISSUES}/{e.issue}"
    # ex: I could use your feedback on this at:\n

    template = None
    label = None
    printed = False
    arena = None
    problem = None
    solutions = None
    status = None
    issue = None

    @property
    def see_issue(self):
        if self.issue:
            return (
                # I'd kinda like to push info/feedback/workarounds to be like
                # options or dynamic or sommink?
                self.SA_TEMPL.format(e=self)
            )
        return NotImplementedError()

    @property
    def description(self):
        if self.problem:
            # "I think it'd be nice to structure these around a core description ({problem}) with some default rules for how to append codes, description links, feedback issues, etc."
            return self.template.format(e=self)
        else:
            raise NotImplementedError("Don't raise ResolutionException directly.")

    @property
    def steps(self):
        return "\n".join(self.solutions)

    def build_template(self):
        template = ""
        if self.label:
            template += "{e.label}"
        if self.problem:
            template += "{e.problem}"
        if self.solutions:
            if len(self.solutions) > 1:
                template += "\n\nNext steps:\n{e.steps}"
            else:
                template += "\n\nNext step: {e.steps}"
        if self.issue:
            template += "\n\n{e.see_issue}"

        return template

    def __init__(self, *args, **kwargs):
        self.arena = kwargs.pop("arena", None)
        self.template = self.build_template()
        ExceptionWithContext.__init__(
            self, self.description, *args, status=self.status, **kwargs
        )

    def print_if_needed(self):
        if not self.printed:
            ui.PrettyPrintError(self, self.arena)
            self.printed = True


class Forbid(ResolutionException):
    pass


class Detain(Forbid):
    pass


class Census(ResolutionException):
    label = "FEEDBACK WANTED: "

    def __init__(self, *args, **kwargs):
        ResolutionException.__init__(self, *args, **kwargs)
        self.print_if_needed()


"""
TODO: I'm waffling a bit on messaging.

I think lucid error communication--what caused resholve to halt, why it
is a problem, and what to do--is important for shifting resholve into
its next phase/gear.

But, they're also the kind of thing I can fritter a lot of time/effort
away on (and they aren't too bad to iterate on). For now, braindump and
disable most 'solutions':
- I'd like to basically workshop the messages towards whether people
  understand what they mean.
- I'm not sure where to come down wrt to linking to a web page/wiki
  and explaining in the message. I've been inclined to see this as
  something I should give more context on here because resholve isn't
  quite a linter--most errors block as you hit them.
- I don't want to get sucked into working on "docs" or a "site".
- I don't want to fritter gobs of time on terse messages that aren't
  detailed enough for anyone to solve their own problems without
  reading the manpage or clicking on a URL anyways?
- I DO want to take time to get the full test stack working again now
  so that it's possible to iterate on these in isolation with a clearer
  ~signal.
"""


class UnresolvedCommand(Forbid):
    problem = "Couldn't resolve command %r"
    # solutions = (
    #     "- add executables to inputs/path",
    #     "- `fake` a function/alias defined elsewhere",
    # )
    status = 3


class UnresolvedSource(Forbid):
    problem = "Unable to resolve source target %r to a known file"
    # solutions = (
    #     "- add it to inputs/path",
    #     "- `fake` a source defined elsewhere",
    # )
    status = 4


class UnexpectedAbsolutePath(Forbid):
    problem = "Unexpected absolute %s path (not supplied by a listed dependency)."
    solutions = ("patch/substitute it.",)
    status = 5


class DynamicArgument(Forbid):
    problem = "Can't resolve dynamic argument in %r"
    # solutions = (
    #     "Decide if this is ",
    #     "- `fake` a source defined elsewhere",
    # )
    status = 6


class DynamicCommand(Forbid):
    problem = "Can't resolve dynamic command"
    # solutions = "TODO: where should they go? Doc? Wiki? Issue?"
    status = 7


class MissingLore(Forbid):
    problem = "I don't have any lore for %r"
    # solutions = "For more on how to supply it, see: TODO"
    status = 8


class PotentialExecer(Forbid):
    problem = (
        "%r _might_ be able to execute its arguments, and I "
        "don't have any command-specific rules for figuring out if this "
        "specific invocation does or not. "
    )
    # solutions = "TODO: where should they go? Doc? Wiki? Issue?"
    status = 9


# TODO: if no other testable assay cases turn up that justify keeping this vague, dial it in; the lone case ATM is for an assay that uses a number that overshoots the length of the command
class InvalidAssay(Forbid):
    problem = "I have an assay matching this invocation, but: %s\n\nAssay: %r"
    # solutions = "TODO: where should they go? Doc? Wiki? Issue?"
    status = 10


class SedECommand(Detain):
    problem = "I don't know how to handle sed `e` commands yet--sorry :("
    solutions = ("- See the feedback issue for a workaround",)
    status = 11
    issue = 28


class NixSetuidWrapper(Detain):
    problem = "There is not yet a good way to resolve '%s' in Nix builds."
    solutions = (
        "- Your feedback will help clarify the best course of action.",
        "- See the workaround in the issue.",
    )
    status = 12
    issue = 29


class OshEvalProblem(Census):
    problem = "OSH eval error while looking for sub-exec in %s %r."
    issue = 30


class OverriddenEssentialBuiltin(Census):
    problem = "Essential builtin overridden by %s %r."
    issue = 27


class QuotedEval(Census):
    problem = "Letting quoted %r through for now."
    issue = 2


# emit census/feedback requests at warning+ verbosity
if logger.isEnabledFor(logging.WARNING):

    def observe(cls, *args, **kwargs):
        try:
            raise cls(*args, **kwargs)
        except Census:
            # these self-print and don't block
            pass


else:

    def observe(cls, *args, **kwargs):
        if isinstance(cls, Census):
            return
        raise cls(*args, **kwargs)


class InFileDirectiveError(Exception):
    directive = path = None
    template = (
        "There's a bad directive already in this file. You may need to\n"
        "re-resholve it with the current version? Here's the context:\n\n"
        "   parsing:  {script}\n"
        " directive:  '{directive}'\n"
        "     error:  {msg}\n"
    )

    def __init__(self, msg, path, directive, *args, **kwargs):
        Exception.__init__(
            self,
            self.template.format(
                msg=msg,
                script=os.path.relpath(path),
                directive=directive[0:-1],  # lop off newline
            ),
            *args,
            **kwargs
        )


class SingleKeyDefaultDict(dict):
    def __init__(self, factory):
        self.factory = factory

    def __missing__(self, key):
        return self.setdefault(key, self.factory(key))


class MultiKeyDefaultDict(dict):
    def __init__(self, factory):
        self.factory = factory

    def __missing__(self, key):
        return self.setdefault(key, self.factory(*key))


"""
It's probably worth discussing the big picture before the next section. It may
be a little arcane, but it's in the service of minimizing repeated work.

When resholve process a script, it runs it through Oil's OSH parser and then
visits the corresponding AST looking for "command-like" words (those used as
if they are a command) to queue them for resolution. On encounter, we can't,
rule out the possibility that it's an alias defined 3 scripts down a source
chain without parsing everything before we start resolving--so we queue.

*(As of May 2021 there's a new wrinkle; we will try to parse/process all
builtins that might lead to sourcing and such during the initial walk.)

On each encounter, the visitor calls a context-specific record_ method from
the RecordCommandlike mixin. Each of these methods corresponds to a known
command resolution order--a sequence of the types of command this command-like
would resolve to. (Resolution rules differ across different contexts, like
inside an alias, and following certain commands). This call:

- Maps the position of the command-like to the AST word object (for reporting)
  self.word_objects[position] = word_object

- Checks defaultdict cmdlikes[word_string] for the CommandLike instance that
  corresponds to this word. This instance will accumulate information like
  which scripts it appears in, whether it's defined as a function or alias,
  and most importantly the distinct resolution orders where it was found.

- Maps the command-like's position to a Solution instance (obtained from the
  CommandLike) that is distinct for each encountered resolution order:
  self.solutions[position] = Solution

  If the visitor encounters the same commandlike 5 separate times but with the
  same resolution order, the solutions dictionary will map *all 5* positions
  to the same object.

Once the visitor has finished, we call CommandLike.resolve() on all known
CommandLike objects. Each CommandLike will "solve" for the distinct contexts
it was found in, and add the appropriate resolution to the corresponding
Solution object. This process records whether each Solution should be a no-op,
raise an exception, or result in a replacement.

Next, we render the resolved script by looping over each of these solutions.
"""


class Solution(object):
    """
    Mutable placeholder objects to pair with commandlike encounters.

    We can't solve the commandlike until we're done parsing, but we
    know enough context at encounter time to deduplicate solutions.
    Calling code will save a reference to the context-appropriate
    solution object for each encounter, and a single solution pass
    later can identify the correct replacement for each one.
    """

    exception = kind = replacement = None

    def __repr__(self):
        if self.solved:
            if self.exception:
                return "Solution(error: {:})".format(self.exception)
            elif isinstance(self.replacement, Iterable):
                return "Solution({:} -> {:})".format(*self.replacement)
            else:
                return "Solution(no-op {:})".format(self.kind)
        else:
            return "Solution(unsolved {:})".format(self.kind)

    def custom(self, kind, initial, replacement):
        self.replacement = (initial, replacement)
        self.kind = kind
        return self

    @property
    def solved(self):
        return self.replacement is not None or self.exception is not None

    def no_change(self, cmdkind):
        self.replacement = False
        self.kind = cmdkind

    def replace_name_with(self, cmdkind, initial, replacement, external=False):
        self.replacement = (initial, replacement)
        self.kind = cmdkind

    def replace_in(self, current):
        return current.replace(*self.replacement)

    def causes_exception(self, exception):
        self.exception = exception


class OrderedCommandResolver(object):
    KNOWN_BUILTINS = {
        ".",
        ":",
        "[",
        "alias",
        "bg",
        "bind",
        "break",
        "builtin",
        "caller",
        "cd",
        "command",
        "compgen",
        "complete",
        "compopt",
        "continue",
        "declare",
        "dirs",
        "disown",
        "echo",
        "enable",
        "eval",
        "exec",
        "exit",
        "export",
        "false",
        "fc",
        "fg",
        "getopts",
        "hash",
        "help",
        "history",
        "jobs",
        "kill",
        "let",
        "local",
        "logout",
        "mapfile",
        "popd",
        "printf",
        "pushd",
        "pwd",
        "read",
        "readarray",
        "readonly",
        "return",
        "set",
        "shift",
        "shopt",
        "source",
        "suspend",
        "test",
        "times",
        "trap",
        "true",
        "type",
        "typeset",
        "ulimit",
        "umask",
        "unalias",
        "unset",
        "wait",
    }
    KNOWN_UNHANDLED_KEYWORDS = {"coproc"}

    @property
    def name(self):
        return self.cmd.name

    @property
    def path(self):
        return self.cmd.path

    def _true(self):
        return True

    def _false(self):
        return False

    def _unexpected_absolute_path(self):
        # any others would be errors, too, but we'll just flag the first
        observe(UnexpectedAbsolutePath, "command")

    def generate_external_resolver(self, relevant):
        if self.name.startswith("/") and os.path.isabs(self.name):
            if (self.name,) in relevant.keep:
                # user said keep this abspath
                return self._true
            elif (self.name,) in relevant.fix:
                # user said to resolve this abspath as if it were bare
                self.cmd.path = self.name
                self.cmd.name = os.path.basename(self.name)
                return self.resolve_external
            else:
                return self._unexpected_absolute_path

        return self.resolve_external

    def __init__(self, commandlike, relevant):
        self.cmd = commandlike
        # "cro" is "command resolution order"; open to renames
        # alias > keyword > special builtin > function > builtin > external
        #                  (POSIX mode only)
        # neither special builtins nor POSIX mode have special handling atm
        # just saving space for them in case...
        self.cro = (
            # TODO: I'm turning these into tuples with a cmdkind string
            # but it might make sense to turn these into constants
            (
                "alias",
                self._true
                if ("alias", self.name) in relevant.fake
                else self.resolve_alias,
            ),
            (
                "keyword",
                self._true
                if ("keyword", self.name) in relevant.fake
                else self.resolve_keyword,
            ),
            ("special_builtin", self.resolve_special_builtin),
            (
                "function",
                self._true
                if ("function", self.name) in relevant.fake
                else self.resolve_function,
            ),
            (
                "builtin",
                self._true
                if ("builtin", self.name) in relevant.fake
                else self.resolve_builtin,
            ),
            (
                "external",
                self._true
                if ("external", self.name) in relevant.fake
                else self.generate_external_resolver(relevant),
            ),
        )

    @property
    def full(self):
        # alias > keyword > special builtin > function > builtin > external
        return self.cro

    @property
    def slash(self):
        # \command skips alias resolution
        # keyword > special builtin > function > builtin > external
        return self.cro[1:]

    @property
    def alias(self):
        return self.cro[3:]  # function > builtin > external

    @property
    def builtin(self):
        return self.cro[4:5]  # builtin

    @property
    def command(self):
        return self.cro[4:]  # builtin > external

    @property
    def external(self):
        return self.cro[5:]  # external

    """
    CommandLike.resolve() will call below methods for each distinct
    CRO encountered, and stop on the first that returns truthy.

    So they have the same basic rules:
    - return True if this is a valid resolution without change
    - return False if not (or None if unimplemented/irrelevant)
    - return a string to indicate a valid resolution with replacement
    - raise an exception to indicate a problem *(see resolve_external
      for a quirk about raising exceptions here)

    TODO: in theory these can be cached, but I'm not sure it'll be
    meaningful. The expensive part, lookup(), is already cached.
        update June 2021: walk-time lookups for some builtins and
        general recursive resolution support *might* have moved the
        needle far enough to justify this change at some point. Not
        something I'll look at until the dust settles and I do a pass
        on perf.
    """

    def resolve_alias(self):
        return self.cmd.alias

    def resolve_keyword(self):
        """
        I wanted to leave this unimplemented and let oil's parser
        shield resholve from needing to worry about it

        but oil doesn't handle the coproc keyword, so that's forcing
        my hand here.
        """
        return True if self.name in self.KNOWN_UNHANDLED_KEYWORDS else False

    def resolve_special_builtin(self):
        """
        leaving special builtin unimplemented for now; it's a
        posix-mode concept I'm hoping to avoid supporting.
        only time it really matters is if a function obscures
        a "special" builtin in posix mode

        See the file 'POSIX_mode_notes'
        """
        pass

    def resolve_function(self):
        return self.cmd.function

    def resolve_builtin(self):
        """
        I'm not sure to what extent I want to support non-bash shells,
        but if there's a push to do so it may help to post this on SO
        or make little help-wanted issues.

        The ~most-right way to do this would be to get the builtins
        from the target shell (at build-time? call-time?) but I'm not
        aware of a portable way to do it.

        If one's identified, the Nix side could accept a shell (or
        shells?) argument, run that command in each, merge the lists,
        and supply them via env.

        For now, I'm just hard-coding a list of bash builtins from
        `compgen -b` run in GNU bash,
        version 5.0.9(1)-release (x86_64-apple-darwin17.7.0)

        NOTE: if you're using resholve for some other shell and have
        a builtin not in this list, you can add an exemption with
        --fake builtin:<name>
        """
        return True if self.name in self.KNOWN_BUILTINS else False

    """
    This is a set of commands that NixOS uses setuid wrappers for.
    I don't know if these are all literally the same case, but I
    know resholve can't safely use `bin/sudo` from a sudo package
    in a Nix build--because we'll bake in a reference to the un-
    wrapped and thus useless copy. Painting them all with the same
    brush unless/until someone informs me otherwise.
    """
    NAUGHTY_NIXERS = (
        "ping",  # macos: /sbin/ping, nix: iputils
        "chsh",  # macos: /usr/bin/chsh, nix: shadow
        "newgrp",  # macos: /usr/bin/newgrp, nix: shadow
        "passwd",  # macos: /usr/bin/passwd, nix: shadow
        "su",  # macos: /usr/bin/su, nix: shadow
        "sudo",  # macos: /usr/bin/sudo, nix: sudo
        "mount",  # macos: /sbin/mount, nix: util-linux
        "umount",  # macos: /sbin/umount, nix: util-linux
    )

    def resolve_external(self):
        if self.name in self.NAUGHTY_NIXERS and "NIX_BUILD_TOP" in os.environ:
            # --fake 'external:sudo' or w/e will let this fall back to
            # a run-time PATH lookup.
            observe(NixSetuidWrapper, self.name)

        global lore
        executable = lookup(self.name)

        if not executable:
            # Types of ExceptionWithContext need other values in order
            # to pretty-print the error location that just aren't
            # readily available at this place using the current logic.
            #
            # Instead, we just mark the status, and code higher up the
            # stack will catch this error, inject the correct arena and
            # location information for us, and then re-raise the error.
            observe(UnresolvedCommand, self.name)
        else:
            # if we know about the executable
            # - and know it cannot exec
            #   - we can move on
            # - otherwise, we need per-invocation triage (but maybe we print a warning that they can help with hinting?)
            # if we don't
            # - either require triage, or outright fail due to the lack of lore
            if executable not in lore:
                observe(MissingLore, executable)

            return executable


"""
We have to handle a few builtins to be able to do much else:
alias
    it can obscure all of our other builtins/commands
.|source
    we need to know we have all functions/aliases defined to be confident about what's unresolved
builtin|command|coproc|eval
    we have to look into these in case they hold instances of the above

CAUTION:
We're flying about as close to the sun as we can without tiptoeing into
symbolic execution. resholve's concept of this won't be robust to a
rapidly-evolving runtime context.
"""

FIRST_PASS_ESSENTIALS = {
    "alias",
    "builtin",
    "command",
    "coproc",
    "eval",
    ".",
    "source",
}


class CommandLike(object):
    """
    Represents each distinct command-like "word" we encounter.

    TODO: explain!
    """

    name = function = alias = path = resolved = None

    def __repr__(self):
        return "CommandLike <%s>" % self.name

    def __init__(self, name):
        self.name = name
        self.known_sources = dict()
        self.known_exemptions = list()
        self.invocations = set()
        self.order_to_source = defaultdict(set)
        self.order_to_solution = defaultdict(Solution)
        self.cros = MultiKeyDefaultDict(OrderedCommandResolver)

    """
    Chomp idiom added May 2021 to address some edge cases with the
    previous process for iterating over commandlikes and invocations.

    CommandLike resolution can now discover new commands/invocations
    to resolve. My intent is to:
    - ~chomp off an entire set of records
    - create an empty set for new records
    - yield the chomped records (to the code resolving them)
    - repeat this process if the new set has records

    See also: resolve_cmdlikes, CommandLike.{request_solution,resolve}
    """
    unresolved = set()  # intentional!

    @classmethod
    def chomp_cmdlikes(cls):
        logger.debug("unresolved clen1 %r %r", len(cls.unresolved), cls.unresolved)
        while len(cls.unresolved):
            unresolved = cls.unresolved
            cls.unresolved = set()
            for cmdlike in unresolved:
                yield cmdlike
            logger.debug("unresolved clen2 %r %r", len(cls.unresolved), cls.unresolved)

    def chomp_invocations(self):
        logger.debug("unresolved ilen1 %r %r", len(self.invocations), self.invocations)
        while len(self.invocations):
            invocations = self.invocations
            self.invocations = set()
            for invocation in invocations:
                yield invocation
            logger.debug(
                "unresolved ilen2 %r %r", len(self.invocations), self.invocations
            )

    def scaffold_new_source(self, source):
        # only exemptions that match this commandlike's name
        # tuple only really for hashability...
        relevant = source.directives.relevant(self.name)

        if relevant in self.known_exemptions:
            # new source, but no novel exemptions
            index = self.known_exemptions.index(relevant)

            # use existing content-identical set to
            # approximate a "set of sets"
            self.known_sources[source] = self.known_exemptions[index]
        else:
            # new source with novel exemptions
            self.known_sources[source] = relevant
            self.known_exemptions.append(relevant)

        return self.cros[(self, relevant)]

    def request_solution(self, source, order, cmd_object):
        self.order_to_source[order].add(source)
        logger.debug(
            "requesting the solution for %r with len=%r",
            cmd_object,
            len(cmd_object.words) if cmd_object else 0,
        )
        CommandLike.unresolved.add(self)
        if cmd_object and len(cmd_object.words) > 1:
            # if there's more than one word, track invocation
            # so that we can check it for sub-executions later
            self.invocations.add((source, cmd_object))
        return self.order_to_solution[order]

    def find_cro(self, source):
        if source not in self.known_sources:
            return self.scaffold_new_source(source)
        return self.cros[(self, self.known_sources[source])]

    def request_full_solution(self, source, cmd_object=None):
        return self.request_solution(source, self.find_cro(source).full, cmd_object)

    def request_slash_solution(self, source, cmd_object=None):
        return self.request_solution(source, self.find_cro(source).slash, cmd_object)

    def request_alias_solution(self, source, cmd_object=None):
        return self.request_solution(source, self.find_cro(source).alias, cmd_object)

    def request_builtin_solution(self, source, cmd_object=None):
        return self.request_solution(source, self.find_cro(source).builtin, cmd_object)

    def request_command_solution(self, source, cmd_object=None):
        return self.request_solution(source, self.find_cro(source).command, cmd_object)

    def request_external_solution(self, source, cmd_object=None):
        return self.request_solution(source, self.find_cro(source).external, cmd_object)

    def _resolve_invocations(self, solution):
        if solution.solved:
            # filter out first-pass, handle builtins, if it's a solved external, handle executions
            if (
                solution.kind in ("builtin", "keyword")
                and self.name in FIRST_PASS_ESSENTIALS
            ):
                pass  # should already be resolved!
            elif solution.kind == "builtin":
                for source, cmd_object in self.chomp_invocations():
                    handler = getattr(
                        source, "handle_builtin_{:}".format(self.name), None
                    )
                    if handler:
                        try:
                            # try/except hopefully obsoleted in
                            # https://github.com/oilshell/oil/issues/956
                            args, name, text = source.get_subexec_context(cmd_object)
                        except (AssertionError, error.FatalRuntime) as e:
                            err_attrs = {
                                key: value
                                for key, value in (
                                    (attr, getattr(e, attr, None))
                                    for attr in ("word", "part", "token", "span_id")
                                )
                                if value
                            }
                            observe(
                                OshEvalProblem,
                                "general builtin",
                                self.name,
                                arena=source.arena,
                                **err_attrs
                            )
                            continue

                        handler(cmd_object, args, name, text)

            elif solution.kind == "external" and isinstance(
                solution.replacement, tuple
            ):
                executable = solution.replacement[1]

                if lore[executable] != "cannot":
                    # otherwise, walk down each execution
                    # chain until we find a terminus
                    for source, cmd_object in self.chomp_invocations():
                        source.look_for_external_sub_execution(self.name, cmd_object)

    def _resolve_cmdlike_contexts(self, distinct_cro, solution):
        # run each function, continue early on exception/true/string
        for cmdkind, func in distinct_cro:
            logger.debug("resolve(%r): trying %r %r", self.name, cmdkind, func)
            try:
                # TODO: could cache these, but not sure it'll make much diff
                test = func()
            except ExceptionWithContext as e:
                solution.causes_exception(e)
                logger.debug("break because exception")
                break

            if test == True:
                solution.no_change(cmdkind)
                logger.debug("break because no change")
                break
            elif test:
                # only external can return more than just t/f
                solution.replace_name_with(cmdkind, self.path or self.name, test)
                for source in self.order_to_source[distinct_cro]:
                    source.directives.keep.add((test,))
                logger.debug("break because replacement")
                break

    def resolve(self):
        global FIRST_PASS_ESSENTIALS, lore
        logger.debug("CALLING RESOLVE ON %r", self.name)

        # find solutions for observed types
        for distinct_cro, solution in self.order_to_solution.items():
            if not solution.solved:
                self._resolve_cmdlike_contexts(distinct_cro, solution)

            self._resolve_invocations(solution)

        self.resolved = True


# TODO: explain!
cmdlikes = SingleKeyDefaultDict(CommandLike)


def resolve_cmdlikes():
    logger.info("Resolving command-likes")
    for cmdlike in CommandLike.chomp_cmdlikes():
        if cmdlike.resolved:
            logger.debug(
                "in resolve_cmdlikes, encountered previously-resolved cmdlike %r %r %r",
                cmdlike.name,
                cmdlike,
                cmdlike.invocations,
            )
        else:
            logger.debug(
                "in resolve_cmdlikes, encountered first-time cmdlike %r %r %r",
                cmdlike.name,
                cmdlike,
                cmdlike.invocations,
            )

        logger.debug("calling cmdlike.resolve(%r) from resolve_cmdlikes", cmdlike.name)
        cmdlike.resolve()


# TODO: refactor down some of this duplication (here and elsewhere)
# keeping it painfully explicit for now to make it easier to
# think/search between different cases here
class RecordCommandlike(object):
    solutions = word_objects = invocations = None

    def __init__(self):
        self.solutions = dict()
        self.word_objects = dict()

    @classmethod
    def disable_alias_replacement(cls):
        cls.record_alias_cmd = cls._disabled_recorder

    def _disabled_recorder(self, *args, **kwargs):
        pass

    def get_word_position(self, word_object, position=None):
        pos = position or word_.LeftMostSpanForWord(word_object)
        self.word_objects[pos] = word_object
        return pos

    def get_subexec_context(self, cmd_object):
        # ex: (cmd_value.Argv argv:[echo blah] arg_spids:[8 10])
        cmd_args = evaluator.EvalWordSequence2(cmd_object.words)
        logger.debug(
            "get_subexec_context %r %r %r", cmd_object, cmd_args, cmd_args.argv
        )
        cmd_name = cmd_args.argv[0] or cmd_object.words[0].parts[0].val
        cmd_text = " ".join(cmd_args.argv)

        return cmd_args, cmd_name, cmd_text

    def handle_builtin_alias(self, cmd_ob, args, name, text):
        """
        aliases seem simple at a blush, but the defs
        can also be very complex...
        alias a=b a="b" a='b' "a=b" 'a=b' a=$b a="$b" a='$b' "a=$b" 'a=$b' 'a=echo $b', etc.

        code is ~v2/3 of trying to handle aliases.
        - v1: try to spot alias identifiers to add to
          allowed unresolved "commands"
        - v2: try to extract alias/expansion pairs to
          - allow unresolved commands
          - make users triage externals in low-hanging-fruit
            alias definitions (resolve? ignore?)
        - v3: roughly v2 except:
          - split out into own method
          - ???

        TODO:
        - do anything else with high-hanging fruit?
        - there may be a generalized handler for "varlikes" here, which
          oil defines as <id>=<stuff> but I'll say is more like:
          [<alias|declare|local|set>] [<<id>=<val>>...]
          (mainly valuable if I decide to consider taking one more firm
          step into dynamic-land by resolving through refs to simple vars)
        """
        logger.debug("alias cmd_ob: %r", cmd_ob)

        for w_ob in cmd_ob.words[1:]:
            w_ok, w_txt, _ = word_.StaticEval(w_ob)
            # Caution: strings w/ varsubs pass static eval here
            # may have to unwrap them first?
            logger.debug(
                "alias (ok? %r) split %r",
                w_ok,
                w_txt.strip("\"='").split("="),
            )
            if w_ok:
                # not dynamic; more examples in tests/aliases.sh, but:
                # 'd', 'echo $SOURCE_DATE_EPOCH'
                alias, definition = w_txt.strip("\"='").split("=")
                # TODO: maybe below deserves an explicit API
                cmdlikes[alias].alias = True
                commandlike = definition.split()[0]

                pos = None

                # Finding pos is a little tricky, so annotating the logic
                # if the alias word has 2 parts, and the 2nd part is a token
                #     pos = the 2nd part's span_id
                # else
                #     *so far* it seems like pos is always
                #     the spid of the last part's first token OR part
                if (
                    w_ob.parts
                    and len(w_ob.parts) == 2
                    and w_ob.parts[1]
                    and isinstance(w_ob.parts[1], Token)
                ):
                    logger.debug(
                        "in any case, %r has a span_id of %r",
                        w_ob.parts[1],
                        w_ob.parts[1].span_id,
                    )
                    pos = w_ob.parts[1].span_id
                else:
                    trg = w_ob.parts[-1]
                    logger.debug(
                        "it should be the second spid of the last part; %r has a span_id of %r",
                        trg,
                        trg.tokens[0].span_id
                        if hasattr(trg, "tokens")
                        else trg.parts[0].span_id,
                    )
                    pos = (
                        trg.tokens[0].span_id
                        if hasattr(trg, "tokens")
                        else trg.parts[0].span_id
                    )

                self.record_alias_cmd(w_ob, commandlike, position=pos)
            # else: # dynamic
            # TODO: decide if you want to emit a warning or error on dynamic aliases?
            #       letting them slide for now.

    def handle_first_pass_essentials(self, txt, cmd_ob):
        global FIRST_PASS_ESSENTIALS, cmdlikes
        subcmd = copy.deepcopy(cmd_ob)
        subcmd.words.remove(subcmd.words[0])
        logger.debug("handle_first_pass_essentials %r %r %r", txt, cmd_ob, subcmd)
        if txt in FIRST_PASS_ESSENTIALS:
            cmdlike = cmdlikes[txt]
            if not cmdlike.alias and not cmdlike.function:
                self.look_for_essential_builtin_sub_execution(txt, subcmd)
                return True
            else:
                raise Exception("shadowed builtin", txt)
        else:
            return False

    def handle_builtin_builtin(self, cmd_ob, args, name, text):
        ok, sw_ob, sw_txt, _quoted = self._require_second_word(name, cmd_ob)
        if ok:
            if not self.handle_first_pass_essentials(sw_txt, cmd_ob):
                subcmd = copy.deepcopy(cmd_ob)
                del subcmd.words[0]
                self.record_builtin_cmd(sw_ob, sw_txt, subcmd)

    # TODO: note migrated from elsewhere:
    # we'll need a function handler for special case
    # functionality like:
    # - substituting command -v -> echo
    # - possibly warning on and requiring an override for `-p`
    def handle_builtin_command(self, cmd_ob, args, name, text):
        ok, sw_ob, sw_txt, _quoted = self._require_second_word(name, cmd_ob)
        if ok:
            if not self.handle_first_pass_essentials(sw_txt, cmd_ob):
                subcmd = copy.deepcopy(cmd_ob)
                del subcmd.words[0]
                self.record_command_cmd(sw_ob, sw_txt, subcmd)

    # TODO: no rush, but maybe we can help the weird coproc
    # situation with a handler that throws better errors
    def handle_builtin_coproc(self, cmd_ob, args, name, text):
        ok, sw_ob, sw_txt, _quoted = self._require_second_word(name, cmd_ob)
        if ok:
            if not self.handle_first_pass_essentials(sw_txt, cmd_ob):
                subcmd = copy.deepcopy(cmd_ob)
                del subcmd.words[0]
                self.record_command_cmd(sw_ob, sw_txt, subcmd)

    def handle_builtin_source(self, cmd_ob, args, name, text):
        """
        CAUTION:
        in a multi-module library, we should:
        - look up targets at their install path to resolve the source statement into
          the correct absolute URI.
        - post-substitute to replace the build-time-path with the install/output path
        """
        target = None

        ok, sw_ob, sw_txt, _quoted = self._require_second_word(name, cmd_ob)
        logger.debug("handle_builtin_source %r %r %r %r", ok, sw_ob, sw_txt, _quoted)

        if not ok:
            logger.debug(
                "Not trying to resolve/parse dynamic source statement. In theory, this should only happen when the dynamic token was exempted with a directive or is in the short list of tokens (like dollar-subs) that we automatically exempt. We obviously can't resolve into the file, but we won't object to the statement. AST: %r",
                cmd_ob,
            )
            return

        if sw_txt.startswith("/") and os.path.isabs(sw_txt):
            # Note: logic here tracks generate_external_resolver()
            if ("source", sw_txt) in self.directives.keep or (
                ".",
                sw_txt,
            ) in self.directives.keep:
                # user said keep this abspath
                self.record_external_source(sw_ob, sw_txt)
                target = False
            elif ("source", sw_txt,) in self.directives.fix or (
                ".",
                sw_txt,
            ) in self.directives.fix:
                # user said to resolve this abspath as if it were bare
                relsw_txt = os.path.basename(sw_txt)
                target = lookup_source(relsw_txt)
                logger.debug(
                    "Looked up source: %r -> %r -> %r",
                    sw_txt,
                    relsw_txt,
                    target,
                )
            else:
                observe(
                    UnexpectedAbsolutePath,
                    "source",
                    word=sw_ob,
                    arena=self.arena,
                )
        else:
            target = lookup_source(sw_txt)
            logger.debug("Looked up source: %r -> %r", sw_txt, target)

        # it was already a valid absolute path
        if target:
            self.record_external_source(sw_ob, sw_txt, replace_with=target)
        # It didn't resolve, or it was an invalid absolute path
        elif target != False:
            # in theory I could pass this exception to the new
            # self.record_external_source, but this would mean we can't
            # fail as soon. Failing soon seems better, no?
            observe(
                UnresolvedSource,
                sw_txt,
                word=sw_ob,
                arena=self.arena,
            )

    def handle_builtin_eval(self, cmd_ob, args, name, text):
        w_ob1 = cmd_ob.words[0]
        try:
            ok, sw_ob, sw_txt, _quoted = self._require_second_word(name, cmd_ob)
        except Forbid as e:
            logger.debug("allowing resolution error for eval %r", e)

        if cmd_ob.words[1].parts[0].tag in (
            word_part_e.SingleQuoted,
            word_part_e.DoubleQuoted,
        ):
            observe(
                QuotedEval,
                w_ob1.parts[0].val,
                word=cmd_ob.words[1],
                arena=self.arena,
            )
            return

    def handle_builtin_exec(self, cmd_ob, args, name, text):
        if len(cmd_ob.words) > 1:
            # presumably a real command we need to recurse on
            subcmd = args.argv[1] or cmd_ob.words[1].parts[0].val
            subcmd_ob = copy.deepcopy(cmd_ob)
            del subcmd_ob.words[0]
            pos = args.arg_spids[1]
            cmdlike = cmdlikes[subcmd]

            solution = None
            if pos in self.solutions:
                solution = self.solutions[pos]
            else:
                solution = self.solutions[pos] = cmdlike.request_external_solution(
                    self, subcmd_ob
                )
                self.word_objects[pos] = cmd_ob.words[1]

            if not solution.solved:
                cmdlike.resolve()

        else:
            # hopefully this is an exec with redirects;
            # I assume we'll just back off
            pass

    def look_for_essential_builtin_sub_execution(self, outer, cmd_object):
        global subcommand_re
        try:
            # try/except hopefully obsoleted in
            # https://github.com/oilshell/oil/issues/956
            args, name, text = self.get_subexec_context(cmd_object)
        except (AssertionError, error.FatalRuntime) as e:
            err_attrs = {
                key: value
                for key, value in (
                    (attr, getattr(e, attr, None))
                    for attr in ("word", "part", "token", "span_id")
                )
                if value
            }
            observe(
                OshEvalProblem,
                "essential builtin",
                outer,
                arena=self.arena,
                **err_attrs
            )
            return

        if name == ".":  # remap
            name = "source"

        handler = getattr(self, "handle_builtin_{:}".format(name), None)
        if handler:
            logger.debug(
                "name %r has subcommand handler: %r %r %r %r",
                outer,
                cmd_object,
                args,
                name,
                text,
            )
            handler(cmd_object, args, name, text)

        else:
            raise Exception(
                "I've made a mistake and there's no handler for this "
                "builtin. Please report it!",
                cmd_object.words[0],
            )

    def _strip_varlikes(self, cmd_ob, args):
        new_cmd = copy.deepcopy(cmd_ob)
        new_args = copy.deepcopy(args)
        logger.debug("WORDS BEFORE %r", new_cmd.words)
        i = len(cmd_ob.words)
        while i > 0:
            i -= 1
            if getattr(new_cmd.words[i].parts[0], "id", None) == Id.Lit_VarLike:
                del new_cmd.words[i]
                del new_args.argv[i]
                del new_args.arg_spids[i]
        logger.debug("WORDS AFTER %r", new_cmd.words)
        return new_cmd, new_args, " ".join(new_args.argv)

    def _handle_executable_flag(flag):
        def temp(self, cmd_ob, args, name, text):
            if len(cmd_ob.words) > 2:
                logger.debug(
                    "handle_executable_flag: %r %r %r %r", name, cmd_ob, args, text
                )

                pos = word = None
                for i, arg in enumerate(args.argv):
                    if arg.startswith(flag):
                        if arg == flag:
                            target = i + 1
                            subcmd = (
                                args.argv[target] or cmd_ob.words[target].parts[0].val
                            )
                            pos = args.arg_spids[target]
                            cmdlike = cmdlikes[subcmd]
                            word = cmd_ob.words[target]
                        elif arg[len(flag)] == "=":
                            # they might all be in one word :/
                            subcmd = arg.split("=")[1]
                            pos = cmd_ob.words[i].parts[-1].span_id
                            cmdlike = cmdlikes[subcmd]
                            # Note: this is a white lie; it's a token, not a word
                            # I don't know if this will break elsewhere...
                            word = cmd_ob.words[i].parts[-1]

                if pos:
                    logger.debug("%r %r %r", subcmd, pos, word)
                    # presumably a real command we need to recurse on
                    solution = None
                    if pos in self.solutions:
                        solution = self.solutions[pos]
                    else:
                        solution = self.solutions[
                            pos
                        ] = cmdlike.request_external_solution(self, cmd_ob)
                        self.word_objects[pos] = word

                    logger.debug(
                        "while handling external flag for %r, recorded solution=%r at pos=%r",
                        cmd_ob,
                        solution,
                        pos,
                    )

                    if not solution.solved:
                        cmdlike.resolve()

        return temp

    def _handle_executable_ignoring_args(
        ignore_positional, ignore_opts, break_double_dash=False
    ):
        """
        flags = [
            (string "arg", int flag args to consume)
            i.e., 0 if it's just a flag, 1 if the flag has 1 arg
            if there are required positional args before
            the subcommand, the first arg should be
            (commandname, int required positional args)
            otherwise, (commandname, 0)
        ]
        """

        def temp(self, cmd_ob, args, name, text):
            logger.debug(
                "handle_executable_ignoring_args: %r %r %r %r", name, cmd_ob, args, text
            )

            pos = word = None
            i = 1  # skip command itself
            drop = ignore_positional
            while i < len(args.argv):
                arg = args.argv[i]
                if break_double_dash and arg == "--":
                    i += 1
                    break

                for needle, skip in ignore_opts:
                    distinct_equal_form = False
                    if needle[-1] == "=":
                        # special-case flags that end with =
                        # assume both 0 and 1-arg forms
                        distinct_equal_form = True
                        needle = needle[0:-1]

                    if arg.startswith(needle):
                        logger.debug("found needle: %r %r %r", arg, needle, skip)
                        if arg == needle:
                            logger.debug("exact match")
                            i += skip + 1
                        elif arg[len(needle)] == "=":
                            if distinct_equal_form:
                                logger.debug("zero-arg alt '=' form")
                                i += 1
                            else:
                                logger.debug("equal after")
                                i += skip

                        logger.debug("break inner loop")
                        break
                else:
                    logger.debug("enter inner-loop's else")
                    logger.debug("test for drop %r", drop)
                    if drop > 1:
                        drop -= 1
                    elif drop == 1:
                        drop -= 1
                        i += 1
                        logger.debug("drop == 1 break")
                        break
                    else:
                        logger.debug("drop < 1 break")
                        break

                logger.debug("reach end of outer while loop")

            word = cmd_ob.words[i]
            ok, word_txt, quoted = word_.StaticEval(word)
            if not ok and self.allow_dynamic_executable_word(cmd_ob.words[i]):
                return  # no-op
            subcmd = args.argv[i] or get_next_val(cmd_ob.words[i])
            pos = args.arg_spids[i]
            cmdlike = cmdlikes[subcmd]
            logger.debug(
                "WOMBLE subcmd=%r pos=%r word=%r cmdlike=%r:%r",
                subcmd,
                pos,
                word,
                cmdlike,
                cmdlike.name,
            )
            if pos:
                # presumably a real command we need to recurse on
                new_cmd = copy.deepcopy(cmd_ob)
                del new_cmd.words[0:i]
                solution = None
                if pos in self.solutions:
                    solution = self.solutions[pos]
                else:
                    solution = self.solutions[pos] = cmdlike.request_external_solution(
                        self, new_cmd
                    )
                    self.word_objects[pos] = word

                logger.debug(
                    "while handling ignored args for %r, recorded solution=%r at pos=%r",
                    new_cmd,
                    solution,
                    pos,
                )

                if not solution.solved:
                    cmdlike.resolve()

        return temp

    # sub-executing coreutils
    # src/chroot.c:execvp
    #   gnu: [OPTION] NEWROOT [COMMAND [ARG]...]
    #   bsd: [-g group] [-G group,group,...] [-u user] newroot [command]
    handle_external_chroot = _handle_executable_ignoring_args(
        1,
        (
            # bsd
            ("--g", 1),
            ("--G", 1),
            ("--u", 1),
            # gnu
            ("--groups", 1),
            ("--userspec", 1),
            ("--skip-chdir", 0),
        ),
    )

    # src/install.c:execlp --strip-program
    handle_external_install = _handle_executable_flag("--strip-program")
    # src/nice.c:execvp Usage: %s [OPTION] [COMMAND [ARG]...]
    handle_external_nice = _handle_executable_ignoring_args(
        0,
        (
            ("-n", 1),
            ("--adjustment", 1),
        ),
    )
    # src/nohup.c:execvp
    # gnu: COMMAND [ARG]...\n\
    # bsd: [--] utility [arguments]
    handle_external_nohup = _handle_executable_ignoring_args(
        0, tuple(), break_double_dash=True
    )
    # src/runcon.c:execvp Usage: %s CONTEXT COMMAND [args]\n\
    handle_external_runcon_context = _handle_executable_ignoring_args(
        1,
        tuple(),
    )
    handle_external_runcon_flags = _handle_executable_ignoring_args(
        0,
        (
            ("-c", 0),
            ("--compute", 0),
            ("-t", 1),
            ("--type", 1),
            ("-u", 1),
            ("--user", 1),
            ("-r", 1),
            ("--role", 1),
            ("-l", 1),
            ("--range", 1),
        ),
    )

    def handle_external_runcon(self, cmd_ob, args, name, text):
        for flag in (
            "-c",
            "--compute",
            "-t",
            "--type",
            "-u",
            "--user",
            "-r",
            "--role",
            "-l",
            "--range",
        ):
            if (" " + flag) in text:
                return self.handle_external_runcon_flags(cmd_ob, args, name, text)

        return self.handle_external_runcon_context(cmd_ob, args, name, text)

    # src/sort.c:execlp --compress-program
    handle_external_sort = _handle_executable_flag("--compress-program")
    # src/split.c:execl --filter=COMMAND
    handle_external_split = _handle_executable_flag("--filter")
    # src/stdbuf.c: OPTION... COMMAND
    handle_external_stdbuf = _handle_executable_ignoring_args(
        0,
        (
            ("-i", 1),
            ("--input", 1),
            ("-o", 1),
            ("--output", 1),
            ("-e", 1),
            ("--error", 1),
        ),
    )
    # src/timeout.c:Usage: %s [OPTION] DURATION COMMAND [ARG]...\n\
    handle_external_timeout = _handle_executable_ignoring_args(
        1,
        (
            ("--preserve-status", 0),
            ("--foreground", 0),
            ("-k", 1),
            ("--kill-after", 1),
            ("-s", 1),
            ("--signal", 1),
            ("-v", 0),
            ("--verbose", 0),
        ),
    )

    """
    /usr/bin/env: illegal option -- h
    usage: env [-iv] [-P utilpath] [-S string] [-u name]
               [name=value ...] [utility [argument ...]]

    Usage: env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]
    Set each NAME to VALUE in the environment and run COMMAND.
          --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND
          --default-signal[=SIG]  reset handling of SIG signal(s) to the default
          --ignore-signal[=SIG]   set handling of SIG signals(s) to do nothing
          --list-signal-handling  list non default signal handling to stderr
      -v, --debug          print verbose information for each processing step
          --help     display this help and exit
          --version  output version information and exit

    A mere - implies -i.  If no COMMAND, print the resulting environment.

    I think this implementation needs to end up doing a general ignore thing on most of these flags, a special ignore thing for varlikes?
        TODO: but note, I guess the ability to ignore varlikes should be very common and very in-the-test-suite
    """
    handle_external_env_options = _handle_executable_ignoring_args(
        0,
        (
            # bsd
            ("-P", 1),
            ("-S", 1),
            ("-u", 1),
            ("-v", 0),
            # gnu
            ("-i", 0),
            ("--ignore-environment", 0),
            ("-0", 0),
            ("--null", 0),
            ("-u", 1),
            ("--unset", 1),
            ("-C", 1),
            ("--chdir", 1),
            ("-S", 1),
            ("--split-string", 1),
            ("--block-signal", 1),
            ("--default-signal", 1),
            ("--ignore-signal", 1),
            ("--list-signal-handling", 1),
            ("-v", 0),
            ("--debug", 0),
        ),
    )

    def handle_external_env(self, cmd_ob, args, name, text):
        new_ob, new_args, new_text = self._strip_varlikes(cmd_ob, args)
        logger.debug("replaced %r %r %r===%r", cmd_ob, new_ob, name, new_args.argv[0])
        return self.handle_external_env_options(
            new_ob, new_args, new_args.argv[0], new_text
        )

    handle_external_sudo_options = _handle_executable_ignoring_args(
        0,
        (
            # sudo -l form
            ("-l", 0),
            ("--list", 0),
            ("-A", 0),
            ("--askpass", 0),
            ("-k", 0),
            ("--reset-timestamp", 0),
            ("-n", 0),
            ("--non-interactive", 0),
            ("-S", 0),
            ("--stdin", 0),
            ("-g", 1),
            ("--group", 1),
            ("-h", 1),
            ("--host", 1),
            ("-p", 1),
            ("--prompt", 1),
            ("-U", 1),
            ("--other-user", 1),
            ("-u", 1),
            ("--user", 1),
            # extra from sans-l form
            ("-b", 0),
            ("--background", 0),
            ("-E", 0),
            ("--preserve-env=", 0),
            ("-H", 0),
            ("--set-home", 1),
            ("-n", 0),
            ("-P", 0),
            ("--preserve-groups", 0),
            ("-C", 1),
            ("--close-from", 1),
            ("-T", 1),
            ("--command-timeout", 1),
            ("-i", 0),
            ("--login", 0),
            ("-s", 0),
            ("--shell", 0),
            # untouched: -B/--bell
        ),
        break_double_dash=True,
    )

    def _find_sed_e_cmd(self, expr):
        """
        '{ s/a/b/ ; s/b/c/e ; }'
        sed: -e expression #1, char 20: e/r/w commands disabled in sandbox mode
        1
        --expression='s/a/b/' -e 's/b/c/e'
        sed: -e expression #2, char 7: e/r/w commands disabled in sandbox mode
        1

        -e 'e echo'
        'sed: -e expression #1, char 1: e/r/w commands disabled in sandbox mode\n'
        """
        sed = lookup("sed")
        if not sed:
            raise Exception(
                "Somehow I ended up trying to look for a sed `e` command in %r when sed isn't even present. Oops! Please report this @ https://github.com/abathur/resholve",
                expr,
            )
        p = Popen(
            [sed, "--sandbox", expr],
            shell=False,
            stdin=PIPE,
            stdout=PIPE,
            stderr=PIPE,
            close_fds=True,
        )
        stdout, stderr = p.communicate(input="something cute")
        #
        if p.returncode == 1 and "commands disabled in sandbox mode" in stderr:
            # gnused e/r/w command present
            # ['sed', '', '-e', 'expression', '#1,', 'char', '1', '', 'e/r/w', 'commands', 'disabled', 'in', 'sandbox', 'mode', '']
            badchar = int(re.split(r"\s|:", stderr)[6])
            badchar -= 1  # adjust 1 -> 0 index

            # trying to work around an issue
            # demo: https://gist.github.com/abathur/ca0c6ca342da292f4361acd826740691
            # report: https://debbugs.gnu.org/cgi/bugreport.cgi?bug=48725
            # my best-guess is that the error, for s cmds, can't trigger until
            # the s-cmd ends? And since s supports internal spaces,
            # that isn't until a brace or a semicolon or the end of the arg?
            # in any case; walk back
            while expr[badchar] in (";", " "):
                badchar -= 1

            if expr[badchar] == "e":
                return True
                # TODO: maybe later we can do something smarter

        return False

    SED_SKIP_SHORT = (
        "-a",  # BSD-only
        "-l",  # BSD-only
        "-n",
        "-E",
        "-r",
        "-s",
        "-u",
        "-h",
        "-z",
        "-v",
    )
    SED_SKIP_LONG = (
        "--quiet",
        "--silent",
        "--debug",
        "--follow-symlinks",
        "--posix",
        "--regexp-extended",
        "--separate",
        "--sandbox",
        "--unbuffered",
        "--help",
        "--null-data",
        "--version",
    )

    def handle_external_sed(self, cmd_ob, args, name, text):
        """
        We want to check sed expressions on the CLI. They can
        either come after an -e/--expression flag, or they can
        be the first ~positional argument as long as -e or -f
        or --expression or --file weren't used.
        """
        logger.debug("trying external sed %r", cmd_ob)
        i = 1
        found_expr = False
        while i < len(args.argv):
            arg = args.argv[i]
            logger.debug("trying arg[%d]: %r", i, arg)
            if arg[0] == "-":
                if arg[1] in ("e", "f"):

                    if self._find_sed_e_cmd(args.argv[i + 1]):
                        observe(
                            SedECommand,
                            word=cmd_ob.words[i + 1],
                            arena=self.arena,
                        )
                    found_expr = True
                    i += 2
                elif arg[1] == "-":
                    if arg.startswith("--expression") or arg.startswith("--file"):
                        if self._find_sed_e_cmd(args.argv[i + 1]):
                            observe(
                                SedECommand,
                                word=cmd_ob.words[i + 1],
                                arena=self.arena,
                            )
                        found_expr = True
                    elif arg.split("=")[0] in self.SED_SKIP_LONG:
                        i += 1
                    elif arg.startswith("--inplace"):
                        i += 2 if "=" in arg else 1
                    elif arg.startswith("--line-length"):
                        i += 2 if "=" in arg else 1
                elif arg in self.SED_SKIP_SHORT:
                    i += 1
                elif arg.startswith("-i "):
                    i += 2
                elif arg.startswith("-i"):
                    i += 1

                continue

            # goal: if we ever get to the end of this loop,
            # assume we've found positional arg 1
            if not found_expr:
                if self._find_sed_e_cmd(args.argv[i]):
                    observe(
                        SedECommand,
                        word=cmd_ob.words[i],
                        arena=self.arena,
                    )

            break

    def handle_external_sudo(self, cmd_ob, args, name, text):
        """
        note that a few of these shouldn't get resolved at all
        NO: sudo -h | -K | -k | -V
        NO: sudo -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]
        NO: sudo -e [-AknS] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ...
        YES: sudo -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]
        YES: sudo [-AbEHknPS] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] [VAR=value] [-i|-s] [<command>]
        """
        # 1. weed out sudo forms that don't need resolving
        # note: some of these long forms aren't known correct
        #       because sudo re-uses a lot of flags
        if len(args.argv) > 1 and args.argv[1] not in (
            "-h",
            "--help",
            "-K",
            "--remove-timestamp",
            "-k",
            "--reset-timestamp",
            "-V",
            "--version",
            "-v",
            "--validate",
            "-e",
            "--edit",
        ):
            # supposedly -l form is the only one that supports vars
            if args.argv[1] == "-l":
                return self.handle_external_sudo_options(cmd_ob, args, name, text)
            else:
                # 2. we need to special-case `--preserve-env=` because there's a
                #    zero-arg form without the =
                new_ob, new_args, new_text = self._strip_varlikes(cmd_ob, args)
                logger.debug(
                    "replaced %r %r %r===%r", cmd_ob, new_ob, name, new_args.argv[0]
                )
                return self.handle_external_sudo_options(
                    new_ob, new_args, new_args.argv[0], new_text
                )

    handle_external_xargs = _handle_executable_ignoring_args(
        0,
        (
            # gnu
            ("-0", 0),
            ("--null", 0),
            ("-a", 1),
            ("--arg-file", 1),
            ("-d", 1),
            ("--delimiter", 1),
            ("-E", 1),
            ("-e=", 1),
            ("--eof=", 0),  # not certain
            ("-I", 1),
            ("-i=", 1),
            ("--replace=", 1),
            ("-L", 1),
            ("--max-lines", 1),
            ("-l", 1),  # TODO: this one probably needs special support
            ("-n", 1),
            ("--max-args", 1),
            ("-o", 0),
            ("--open-tty", 0),
            ("-P", 1),
            ("--max-procs", 1),
            ("-p", 0),
            ("--interactive", 0),
            ("--process-slot-var", 1),
            ("-r", 0),
            ("--no-run-if-empty", 0),
            ("-s", 1),
            ("--max-chars", 1),
            ("--show-limits", 0),
            ("-t", 0),
            ("--verbose", 0),
            ("-x", 0),
            ("--exit", 0),
            ("--help", 0),  # TODO: not really sure if help/vers are needed
            ("--version", 0),
            # bsd seems to have at least one extra
            ("-J", 1),
        ),
    )

    handle_external_rlwrap = _handle_executable_ignoring_args(
        0,
        (
            ("-a", 1),
            ("--always-readline", 1),
            ("-A", 0),
            ("--ansi-colour-aware", 0),
            ("-b", 1),
            ("--break-chars", 1),
            ("-c", 0),
            ("--complete-filenames", 0),
            ("-C", 1),
            ("--command-name", 1),
            ("-D", 1),
            ("--history-no-dupes", 1),
            ("-e", 1),
            ("--extra-char-after-completion", 1),
            ("-f", 1),
            ("--file", 1),
            ("-g", 1),
            ("--forget-matching", 1),
            ("-h", 0),
            ("--help", 0),
            ("-H", 1),
            ("--history-filename", 1),
            ("-i", 0),
            ("--case-insensitive", 0),
            ("-I", 0),
            ("--pass-sigint-as-sigterm", 0),
            ("-l", 1),
            ("--logfile", 1),
            ("-m", 1),
            ("--multi-line", 1),
            ("-M", 1),
            ("--multi-line-ext", 1),
            ("-n", 0),
            ("--no-warnings", 0),
            ("-N", 0),
            ("--no-children", 0),
            ("-o", 0),
            ("--one-shot", 0),
            ("-O", 1),
            ("--only-cook", 1),
            ("-p", 1),
            ("--prompt-colour", 1),
            ("-P", 1),
            ("--pre-given", 1),
            ("-q", 1),
            ("--quote-characters", 1),
            ("-r", 0),
            ("--remember", 0),
            ("-R", 0),
            ("--renice", 0),
            ("-s", 1),
            ("--histsize", 1),
            ("-S", 1),
            ("--substitute-prompt", 1),
            ("-t", 1),
            ("--set-term-name", 1),
            ("-U", 0),
            ("--mirror-arguments", 0),
            ("-v", 0),
            ("--version", 0),
            ("-w", 1),
            ("--wait-before-prompt", 1),
            ("-W", 0),
            ("--polling", 0),
            # TODO: these last two may need their own
            # resolution? unsure.
            ("-z", 1),
            ("--filter", 1),
        ),
    )
    handle_external_sqlite3 = _handle_executable_flag("--cmd")

    def look_for_external_sub_execution(self, outer, cmd_object):
        global decided_execers, lore

        try:
            # try/except hopefully obsoleted in
            # https://github.com/oilshell/oil/issues/956
            args, name, text = self.get_subexec_context(cmd_object)
        except (AssertionError, error.FatalRuntime) as e:
            err_attrs = {
                key: value
                for key, value in (
                    (attr, getattr(e, attr, None))
                    for attr in ("word", "part", "token", "span_id")
                )
                if value
            }
            observe(OshEvalProblem, "external", outer, arena=self.arena, **err_attrs)
            return

        logger.debug(
            "look_for_external_sub_execution0: %r %r outer=%r name=%r %r",
            cmd_object,
            args,
            outer,
            name,
            text,
        )

        if len(args.argv) >= 1:
            pos = args.arg_spids[0]
            subcmd_txt = args.argv[0] or cmd_object.words[0].parts[0].val
            cmdlike = cmdlikes[subcmd_txt]

            solution = None
            if pos in self.solutions:
                solution = self.solutions[pos]
            else:
                solution = self.solutions[pos] = cmdlike.request_external_solution(
                    self, cmd_object
                )
                self.word_objects[pos] = cmd_object.words[0]

            logger.debug(
                "while seeking external subexec for %r, recorded solution=%r at pos=%r cmdlike=%r",
                cmd_object,
                solution,
                pos,
                cmdlike.name,
            )

            if not solution.solved:
                cmdlike.resolve()

            if solution.exception:
                return

            replacement = solution.replacement[1] if solution.replacement else None
            if len(args.argv) == 1 or (
                replacement and replacement in lore and lore[replacement] == "cannot"
            ):
                logger.debug("allowing safe-passage for executable declared 'cannot'")
                return

        logger.debug(
            "look_for_external_sub_execution1: %r %r outer=%r name=%r %r",
            cmd_object,
            args,
            outer,
            name,
            text,
        )

        if outer in decided_execers:
            assay = decided_execers[outer]
            wordnum = int(assay["wordnum"])
            logger.debug(
                "outer=%r assay=%r wordnum=%r text=%r", outer, assay, wordnum, text
            )
            if assay["command"] == text:
                if wordnum >= len(args.arg_spids):
                    observe(
                        InvalidAssay,
                        "the wordnum index(%d) is too large to zero-index args(%d)"
                        % (wordnum, len(args.arg_spids)),
                        assay,
                        word=cmd_object.words[-1],
                        arena=self.arena,
                    )
                pos = args.arg_spids[wordnum]
                subcmd_txt = (
                    args.argv[wordnum] or cmd_object.words[wordnum].parts[0].val
                )
                logger.debug("assay.command == text")
                # contra to the normal process--we'll register and
                # then immediately resolve this (if it isn't already)
                cmdlike = cmdlikes[subcmd_txt]

                solution = None
                if pos in self.solutions:
                    solution = self.solutions[pos]
                else:
                    solution = self.solutions[pos] = cmdlike.request_external_solution(
                        self, cmd_object
                    )
                    self.word_objects[pos] = cmd_object.words[wordnum]

                logger.debug(
                    "look_for_external_sub_execution2: %r %r %r %r %r",
                    cmdlike,
                    solution,
                    pos,
                    subcmd_txt,
                    solution.solved,
                )
                if not solution.solved:
                    cmdlike.resolve()

                logger.debug(
                    "look_for_external_sub_execution3: %r %r %r %r %r",
                    cmdlike,
                    solution,
                    pos,
                    subcmd_txt,
                    solution.solved,
                )
                if solution.solved:
                    return

        handler = getattr(self, "handle_external_{:}".format(name), None)
        if handler:
            logger.debug(
                "calling %r(ob=%r, args=%r, name=%r, text=%r)",
                handler,
                cmd_object,
                args,
                name,
                text,
            )
            handler(cmd_object, args, name, text)
            return
        elif outer in subcommand_re:
            logger.debug("name %r has subcommand regex", outer)
            logger.debug("about to search %r for %r", text, subcommand_re[outer])
            match = subcommand_re[outer].search(text)
            if match:
                # TODO:
                # - future of subcommand_re is generally tenuous/in-question
                #   don't spend too much time on any specific TODOs in here until
                #   you know you're keeping the pattern
                # - subcmd_txt is currently unused here and in prune
                #   but not quite comfortable throwing it out the window yet
                #   kill if still here after June 2021
                subcmd_txt = match.group("resolve")
                start, end = match.span("resolve")

                # copy the command and knock out words/tokens that the
                # matcher didn't match
                subcmd = copy.deepcopy(cmd_object)
                self.prune_unmatched(subcmd, subcmd_txt, start, end)

                self.look_for_external_sub_execution(
                    # TODO: I don't like all of the repeat fw-finding logic
                    # is there a smarter way?
                    subcmd.words[0].parts[0].val,
                    subcmd,
                )

            # TODO: we're basically trusting the matcher to not suck, here
            # which may be fine, or maybe we should be more pedantic?
            return

        observe(
            PotentialExecer,
            name,
            word=cmd_object.words[0],
            arena=self.arena,
        )

    def prune_unmatched(self, cmd_object, subcmd_txt, start, end):
        """
        Walk the command's words to knock out the parts before/after
        the matched range.

        TODO: think about working from the end to avoid the list
        alloc and loop?
        """
        pos = 0
        unmatched_words = list()
        for word in cmd_object.words:
            pos += get_word_len(word)

            if pos <= start:
                pos += 1  # 1 for space between words
                unmatched_words.append(word)
                if pos == start:
                    continue

            # TODO unclear how real the threat of overflow that would require
            # weighing at the sub-word/part level is?
            elif pos <= end:
                pos += 1  # 1 for space between words
            elif pos > end:
                unmatched_words.append(word)
                pos += 1  # 1 for space between words

        logger.debug(
            "prune_unmatched is removing %r from %r", unmatched_words, cmd_object
        )
        for word in unmatched_words:
            cmd_object.words.remove(word)

        logger.debug("prune_unmatched leaves: %r", cmd_object)

    def record_general_cmd(self, word_object, word_text, cmd_object, position=None):
        """Record command found in general namespace."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_full_solution(
            self, cmd_object
        )

    def record_slash_cmd(self, word_object, word_text, cmd_object, position=None):
        """Record \command in general namespace - aliases."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_slash_solution(
            self, cmd_object
        )

    def record_alias_cmd(self, word_object, word_text, position=None):
        """Record command found in alias definition namespace."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_alias_solution(
            self,
        )

    def record_builtin_cmd(self, word_object, word_text, cmd_object, position=None):
        """Record command argument to `builtin` builtin :)"""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_builtin_solution(
            self, cmd_object
        )

    def record_command_cmd(self, word_object, word_text, cmd_object, position=None):
        """Record command argument to `command` builtin."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_command_solution(
            self, cmd_object
        )

    def record_external_cmd(self, word_object, word_text, cmd_object, position=None):
        """Record command argument to commands known to run externals."""
        pos = self.get_word_position(word_object, position)
        self.solutions[pos] = cmdlikes[word_text].request_external_solution(
            self, cmd_object
        )

    def record_external_source(
        self, word_object, word_text, replace_with=None, position=None
    ):
        """
        Record file argument to `source` builtin.

        CAUTION:
        This has the same basic effect as the others, but it uses
        slightly different logic. In short, the others are for queueing late
        resolution of each command-like. We *could* do that here--but we have
        to parse each source *before* we can late-resolve everything else
        correctly.

        So, in this one case, we'll immediately resolve and parse these.
        """
        global resolved_scripts
        source = None
        pos = self.get_word_position(word_object, position)
        sol = self.solutions[pos] = Solution()
        if replace_with:
            # TODO: see note about constant cmdkind
            sol.replace_name_with("source", word_text, replace_with)
            source = replace_with
        else:
            # TODO: see note about constant cmdkind
            sol.no_change("source")
            source = word_text

        logger.info("Resolving source")

        if (
            source not in resolved_scripts
            and ("source", source) not in self.directives.fake
        ):
            logger.info("Parsing sourced script %r", source)
            resolved = self.__class__(source)
            resolved_scripts[source] = resolved

        self.directives.keep.add(
            (
                "source",
                source,
            )
        )


evaluator = None


class ResolvedScript(RecordCommandlike):
    """
    Represent each individual script that we resolve.
    """

    @staticmethod
    def _make_parser(parse_ctx, script, arena):
        """
        Do the last few steps to make a file-specific parser.
        """
        return parse_ctx.MakeOshParser(reader.FileLineReader(script, arena))

    def replace_shebang(self, fileob, shebang=False):
        """
        - skip over the shebang lines, else raise
        - prepend new shebang if available
        """
        pos = fileob.tell()
        line = fileob.readline()

        while line[0:2] == "#!":
            if shebang is False:
                raise Exception(
                    "Oh gosh :( you gotta get this shebang looked at", line, pos
                )
            elif shebang or shebang is None:
                logger.debug("Skipping shebang line: %r", line)

            pos = fileob.tell()
            line = fileob.readline()

        logger.debug("First non-shebang line: %r", line)
        fileob.seek(pos)
        logger.debug("appending shebang: %r", shebang)
        return StringIO.StringIO((shebang if shebang else "") + fileob.read())

    def __init__(
        self,
        script_path=None,
        shebang="",
        prologue=None,
        epilogue=None,
    ):
        global evaluator
        # generally, defer work until we know the script loaded
        with (
            open(script_path) if script_path else io.BytesIO(sys.stdin.read())
        ) as script:
            if shebang:
                script = self.replace_shebang(script, shebang)

            arena = alloc.Arena()

            # opts = state.InitOpts()

            parse_ctx = parse_lib.ParseContext(
                arena=arena,
                parse_opts=optview.Parse(state.InitOpts(), NO_OPTIONS_OVERLAY),
                aliases={},  # dummy
                oil_grammar=None,
            )
            parse_ctx.Init_OnePassParse(True)

            if script_path:
                # TODO: is there a real difference between using mainfile and
                # sourcedfile? (this gets re-used for sourced scripts)
                arena.PushSource(source.MainFile(script_path))
            else:
                arena.PushSource(source.Stdin())

            # Note: dict below is for envs, i.e. {"HOME": "/noplacelike"}
            mem = state.Mem("", list(), dict(), arena)
            parse_opts, exec_opts, mutable_opts = state.MakeOpts(mem, None)
            mem.exec_opts = exec_opts

            splitter = split.SplitContext(mem)
            errfmt = ui.ErrorFormatter(arena)
            # TODO: ask andy about these as well
            evaluator = word_eval.CompletionWordEvaluator(
                mem, exec_opts, mutable_opts, splitter, errfmt
            )
            evaluator.arith_ev = sh_expr_eval.ArithEvaluator(
                mem, exec_opts, parse_ctx, errfmt
            )
            evaluator.arith_ev.word_ev = evaluator

            # set([ (scope, identifier), ... ])
            self.directives = ResolutionDirectives()
            self.parse_directives(script, script_path)

            try:
                node = main_loop.ParseWholeFile(
                    self._make_parser(parse_ctx, script, arena)
                )
            except error.Parse as e:
                e.arena = arena
                raise

        assert node is not None

        # actually initialize
        RecordCommandlike.__init__(self)
        self.arena = arena
        self.root = node
        self.prologue = prologue
        self.epilogue = epilogue

        # "resolve"
        try:
            self.Visit(node)
            self.handle_potential_redefiners()
        except Forbid as e:
            e.print_if_needed()
            raise e

    def parse_directives(self, script, path):
        """
        read the tail of the file for directives;
        abort as soon as we find a nonmatching line

        # resholve: <type> scope:<identifier>
        """
        global directives
        path = path if path else "<stdin>"
        self.in_doc_directives = ResolutionDirectives()
        for line in script:
            if line.startswith("# resholve: "):
                try:
                    if line.startswith("# resholve: allow"):
                        raise InFileDirectiveError(
                            "While parsing resholve directives already in this "
                            "script, I encountered an 'allow' directive from "
                            "resholve(d)'s pre-history. The program no longer "
                            "supports this directive format--you'll have to "
                            "re-resholve this script with a modern version. ",
                            path,
                            line,
                        )
                    elif line.startswith("# resholve: fake"):
                        self.in_doc_directives.fake.update(
                            directive_fake(line[17:].strip())
                        )
                    elif line.startswith("# resholve: fix"):
                        self.in_doc_directives.fix.update(
                            directive_fix(line[16:].strip())
                        )
                    elif line.startswith("# resholve: keep"):
                        self.in_doc_directives.keep.update(
                            directive_keep(line[17:].strip())
                        )
                except argparse.ArgumentTypeError as e:
                    raise InFileDirectiveError(e.message, path, line)
            elif line.startswith(
                "### resholve directives (auto-generated) ## format_version: "
            ):
                # some modern version
                version = line[60:].strip()
                if version != DIRECTIVE_FORMAT:
                    logger.warning(
                        "resholve version {:} with *native* directive "
                        "fmt v{:} parsing directive fmt v{:}".format(
                            __version__, DIRECTIVE_FORMAT, version
                        )
                    )
            # older directive separator
            elif line.startswith("### resholve directives (auto-generated)"):
                # some modern version
                version = "1"
                if version != DIRECTIVE_FORMAT:
                    logger.warning(
                        "resholve version {:} with *native* directive "
                        "fmt v{:} parsing directive fmt v{:}".format(
                            __version__, DIRECTIVE_FORMAT, version
                        )
                    )
        script.seek(0)
        self.directives.update(self.in_doc_directives, directives)

    def write_directives(self, cursor):
        global DIRECTIVE_FORMAT
        template = "\n### {:} ## {:}: {:}\n"
        # we only want items that weren't already in the file
        if len(self.in_doc_directives) < len(self.directives):
            if len(self.in_doc_directives) == 0:
                cursor.f.write(
                    template.format(
                        "resholve directives (auto-generated)",
                        "format_version",
                        DIRECTIVE_FORMAT,
                    )
                )
            new_directives = self.directives.difference(self.in_doc_directives)
            cursor.f.writelines(
                [
                    self.write_directive(directive)
                    for directive in sorted(new_directives)
                ]
                + ["\n"]
            )

    @staticmethod
    def write_directive(directive):
        if len(directive) == 3:
            return "# resholve: {:} {:}:{:}\n".format(*directive)
        elif len(directive) == 2:
            return "# resholve: {:} {:}\n".format(*directive)

    def write_to(self, path=None):
        f = open(path, "w") if path else sys.stdout
        try:
            self.render(to=f)
        except Forbid as e:
            e.print_if_needed()
            raise e
        finally:
            f.close()

    def render(self, to=sys.stdout):
        cursor = osh2oil.Cursor(self.arena, to)

        replacements = sorted(self.solutions.keys())
        if len(replacements):
            logger.info("Making replacements")
            logger.debug("  The replacements are: %r", self.solutions)
            logger.debug("  They'll be made in this order: %r", replacements)

        # if the user has specified a prepend string, find the first
        # actual code span, so that we can inject before it.
        if self.prologue:
            first_span = find_earliest_spid(self.root)
            cursor.PrintUntil(first_span)
            to.write("\n# begin prologue inserted by resholve\n")
            to.write(self.prologue.read())
            to.write("\n# end prologue inserted by resholve\n")
            cursor.PrintUntil(first_span + 1)

        for location in replacements:
            solution = self.solutions[location]

            logger.debug("handling replacements: %r", location)

            e = solution.exception
            if e:
                e.word = self.word_objects[location]
                e.span_id = location
                e.arena = self.arena
                raise e
            elif solution.replacement:
                logger.debug("pre-replacement %r", location)
                cursor.PrintUntil(location)

                logger.debug("printed up to %r", location)
                span = self.arena.GetLineSpan(location)

                line = self.arena.GetLine(span.line_id)
                current = line[span.col : span.col + span.length]
                logger.debug(
                    "identified span=%r, line=%r, current=%r, replacement=%r",
                    span,
                    line,
                    current,
                    solution.replace_in(current),
                )
                if current[0:1] == "\\":
                    to.write(current.replace(current[1:], solution.replacement[1]))
                    location += 1
                else:
                    to.write(solution.replace_in(current))

                logger.debug("replacement written and skipping to %r", location + 1)

                # we already wrote this one; leapfrog
                cursor.SkipUntil(location + 1)
            elif e:
                e.word = self.word_objects[location]
                e.span_id = location
                e.arena = self.arena
                raise e

        cursor.PrintUntil(self.arena.LastSpanId())

        if self.epilogue:
            to.write("\n# begin epilogue inserted by resholve\n")
            to.write(self.epilogue.read())
            to.write("\n# end epilogue inserted by resholve\n")

        self.write_directives(cursor)
        self.arena.PopSource()
        return self

    def allow_dynamic_token(self, token, word_ob, fw_txt=None):
        if fw_txt == "eval":
            logger.info(
                "allowing eval with dynamic argument %r",
                token,
            )
            return True
        elif token.id == Id.Left_Backtick:
            logger.info(
                "allowing left backtick; should be a command-sub separately visited? %r",
                token,
            )
            return True
        # ~number subs are probably okayish?
        elif token.id in (Id.VSub_Number, Id.VSub_At, Id.VSub_Star):
            logger.info(
                "allowing dynamic command (first-word variable) with positional ($1, $@, $*) varsub %r:%r",
                fw_txt,
                token.val,
            )
            return True
        else:
            # extract a name normalized
            # across braced and unbraced subs
            token_name = None
            if token.id == Id.VSub_Name:
                # add $ prefix
                token_name = "${:}".format(token.val)
            elif token.id == Id.VSub_DollarName:
                # it already has $ prefixed
                token_name = token.val
            elif token.id == Id.Lit_TildeLike:
                # try to get the text
                # confidence in approach: medium
                left, right = span_pair(word_ob, self.arena)
                line = self.arena.GetLine(left.line_id)
                start = left.col
                end = right.col + right.length
                token_name = line[start:end]

            # start making real decisions
            if fw_txt:
                # TODO: practice below mostly considers part vars like
                # $HOME/blah or $PREFIX/blah, but there are other
                # patterns a more sophisticated version could address.
                # At the moment those would need to be manually
                # patched. I'd like to follow this definition back to
                # the vardef and register it for substitution if it's
                # a simple string, flatten here and reconsider.

                # Letting ${name}-style subs through only if they're in
                # a list of allowed names. (goal: require conscious
                # exceptions, but make them easy to add)
                if (
                    fw_txt,
                    token_name,
                ) in self.directives.keep:
                    logger.debug(
                        "allowing dynamic argument %r:%r",
                        fw_txt,
                        token_name,
                    )
                    return True

                observe(
                    DynamicArgument,
                    fw_txt,
                    token=token,
                    arena=self.arena,
                )
            else:
                if (token_name,) in self.directives.keep:
                    # skip exempted name
                    logger.info(
                        "allowing exempted dynamic command %r",
                        token_name,
                    )
                    return True

                observe(
                    DynamicCommand,
                    token=token,
                    arena=self.arena,
                )

    def allow_dynamic_executable_word(self, word_ob, fw_txt=None):
        """
        Handle a word that didn't pass StaticEval
        """
        dynamic = None
        for part in word_ob.parts:
            if part.tag == word_part_e.CommandSub:
                logger_debug(
                    "allow_dynamic_executable_word: skip dynamic-token in command-sub; cmd visitor should handle inside..."
                )
                return True

            dynamic = find_dynamic_token(part)
            if dynamic and not self.allow_dynamic_token(dynamic, word_ob, fw_txt):
                raise Exception(
                    "I'm not convinced this is possible anymore, so speciating the messages is a waste of time.",
                    word_ob,
                    dynamic,
                )
                observe(
                    DynamicCommand,
                    word=word_ob,
                    token=dynamic,
                    status=9,
                    arena=self.arena,
                )
            else:
                return True

        if dynamic is None:
            # this can be logged if it is real, but I'm making it an exception for now to validate whether it is real?
            raise Exception(
                "Couldn't statically evaluate 1st word object %r, but also failed to find a dynamic token?!",
                word_ob,
            )

        return False

    def _require_second_word(self, fw_txt, cmd_ob):
        """
        returns ok (bool static/dynamic), sw_ob, sw_text if static, bool quoted
        """
        if len(cmd_ob.words) > 1:
            word_ob = cmd_ob.words[1]
            ok, word_txt, quoted = word_.StaticEval(word_ob)
            if not ok:
                logger.info("   Command is dynamic, %r", cmd_ob)
                self.allow_dynamic_executable_word(word_ob, fw_txt)

            return ok, word_ob, word_txt, quoted

    def handle_potential_redefiners(self):
        logger.info(
            "TODO: this is where to process builtins that might mod execution context (enable, unset, unalias?)"
        )

    def _visit_command_Simple(self, cmd_ob):
        global FIRST_PASS_ESSENTIALS
        if not cmd_ob.words:
            return

        fw_ob = cmd_ob.words[0]
        ok, fw_txt, quoted = word_.StaticEval(fw_ob)

        if not ok:
            self.allow_dynamic_executable_word(fw_ob, fw_txt)
        else:
            if fw_ob.parts[0].tag == word_part_e.EscapedLiteral:
                self.record_slash_cmd(fw_ob, fw_txt, cmd_ob)
            else:
                self.record_general_cmd(fw_ob, fw_txt, cmd_ob)
            # handle essential builtins immediately
            if fw_txt in FIRST_PASS_ESSENTIALS:
                cmdlike = cmdlikes[fw_txt]
                logger.debug(
                    "FIRST_PASS_ESSENTIAL (%r): %r %r", fw_txt, cmdlike, cmd_ob
                )
                if not cmdlike.alias and not cmdlike.function:
                    return self.look_for_essential_builtin_sub_execution(fw_txt, cmd_ob)

                observe(
                    OverriddenEssentialBuiltin,
                    "function" if cmdlike.function else "alias",
                    fw_txt,
                    word=fw_ob,
                    arena=self.arena,
                )

    def _visit_command_ShFunction(self, node):
        cmdlikes[node.name].function = True

    def _Visit(self, node):
        cls = node.__class__
        # TODO: maybe a custom loglevel for this? It's useful, but
        # very situational and very spammy (especially on very large
        # scripts). For now, just uncomment as needed...
        # logger.debug("Visiting node %r (class: %r)", node, cls)
        if cls is command.Simple:
            self._visit_command_Simple(node)

        elif cls is command.ShFunction:
            self._visit_command_ShFunction(node)

    def Visit(self, node):
        self._Visit(node)
        self.VisitChildren(node)

    # borrowed from Visitor in oil/tools/deps.py
    # seems like a lot to import for...
    def VisitChildren(self, node):
        """
        Args:
          node: an ASDL node.
        """

        for name in node.__slots__:
            child = getattr(node, name)
            if isinstance(child, list):
                for item in child:
                    if isinstance(item, pybase.CompoundObj):
                        self.Visit(item)
                continue

            if isinstance(child, pybase.CompoundObj):
                self.Visit(child)
                continue


if __name__ == "__main__":
    # punshow()  # DEBUG: toggle comments here when you want exceptions
    sys.exit(punshow())
