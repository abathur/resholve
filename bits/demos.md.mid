```

## Nix demo

This demo illustrates how to use resholve in Nix to compose a set of modules together. You can see the Nix code for the modules in [nixpkgs/test.nix](nixpkgs/test.nix), and their shell scripts in [tests/nix](tests/nix/). The modules are:

- `test_module1` - Depends on the jq and libressl executables, and on test_module2.
- `test_module2` - Depends on the openssl executable, and the shunit2 module/shell library.
- `test_module3` - Depends on test_module1.

This demo (which is just a shell script executing with `set -x` enabled around points of interest) is a little harder to follow, so I'll run down the points of interest before throwing you in:

- The demo runs by executing conjure.sh with a clean environment (i.e `env -i $(type -p conjure.sh)`). *It is not depending on its run-time environment!*
- Before any output begins, `conjure.sh` (test_module3) sources `libressl.sh` (test_module1), which sources `openssl.sh` (test_module2), which sources `shunit2`. *Everything is in one shell namespace when the test begins.*
- When `shunit2` is sourced, it automatically collects and runs functions named test_*.
- `type jq openssl` demonstrates that the jq and openssl executables aren't on the PATH. *Dependencies declared for one module/script aren't leaking into others!*
- Both `openssl.sh` and `libressl.sh` invoke `openssl`, but *because the scripts were separately resolved by Nix and resholve, `openssl.sh` correctly invokes `OpenSSL x.y.z`, while `libressl.sh` correctly invokes `LibreSSL x.y.z`!*

After the output from running the demo, it'll output the resholved source of conjure.sh, openssl.sh, and libressl.sh.

The Nix demo is currently tied into resholve's CI run, so for now you'll have to run the whole thing if you want to see it locally:

```shell
nix build .#ci --print-build-logs
```

The result will be something like:

```shell
$ nix build .#ci --print-build-logs
...
